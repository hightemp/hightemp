# Каким правилам нужно следовать чтобы оптимизировать свой код под процессор(кэш) на golang?

## 1. Правильное расположение данных

- **Размещайте связанные данные рядом** в памяти, чтобы улучшить локальность кэша
- **Используйте структуры вместо отдельных переменных**
- **Учитывайте выравнивание данных**:
  ```go
  // Плохо (из-за padding)
  type BadStruct struct {
      a byte
      b int64
      c byte
  }
  
  // Лучше
  type GoodStruct struct {
      b int64
      a byte
      c byte
  }
  ```

## 2. Оптимизация доступа к памяти

- **Обходите массивы последовательно** (по строкам для многомерных массивов)
  ```go
  // Эффективный доступ (row-major order)
  for i := 0; i < rows; i++ {
      for j := 0; j < cols; j++ {
          matrix[i][j] = value
      }
  }
  ```

- **Предварительно выделяйте память** для слайсов с известным размером
  ```go
  // Предвыделение памяти
  data := make([]int, 0, expectedSize)
  ```

## 3. Избегайте индирекции и указателей

- **Предпочитайте массивы значений**, а не массивы указателей
- **Используйте встраиваемые структуры** вместо указателей на них
- **Минимизируйте разыменование указателей** в критических участках кода

## 4. Специфичные для Go оптимизации

- **Используйте sync.Pool** для повторного использования объектов
- **Избегайте избыточной аллокации памяти** в циклах
- **Применяйте префетчинг** для критических данных:
  ```go
  import "github.com/golang/go/src/runtime/internal/sys"
  
  // Подсказка процессору предзагрузить данные
  sys.Prefetch(unsafe.Pointer(&data[nextIndex]))
  ```

## 5. Инструменты для профилирования

- **pprof** для анализа производительности
- **go test -bench** для микробенчмаркинга
- **runtime/trace** для детального анализа исполнения

## 6. Дополнительные рекомендации

- **Избегайте ложного разделения (false sharing)** в многопоточных программах
- **Выбирайте подходящие размеры для внутренних буферов**
- **Учитывайте размер строки кэша** (обычно 64 байта) при проектировании структур данных

---

## Избегайте ложного разделения (false sharing)

**Ложное разделение** — это ситуация, возникающая в многопоточных программах, когда несколько потоков обращаются к разным переменным, которые находятся в одной линии кэша процессора, что вызывает неэффективную синхронизацию кэша между ядрами.

### Почему это важно
Когда одно ядро модифицирует данные в строке кэша, вся строка кэша становится недействительной для других ядер, даже если они используют другие переменные в той же строке.

### Решение
```go
// Плохо - вероятно ложное разделение
type Counter struct {
    value1 int64
    value2 int64
}

// Лучше - с защитой от ложного разделения
type Counter struct {
    value1 int64
    // padding для выравнивания по границе кэш-линии
    _ [56]byte // 64 байта (размер кэш-линии) - 8 байт (int64)
    value2 int64
}
```

Также можно использовать пакет `github.com/intel-go/cpuid` для определения размера строки кэша в рантайме.

## Выбирайте подходящие размеры для внутренних буферов

### Почему это важно
Размер буфера влияет на:
- Эффективность использования кэша
- Частоту промахов кэша
- Количество операций выделения памяти

### Рекомендации
- **Учитывайте паттерны доступа**: буферы, размер которых кратен размеру строки кэша (64 байта), обеспечивают лучшую производительность
- **Избегайте слишком маленьких буферов**: это ведет к частым аллокациям
- **Избегайте слишком больших буферов**: они могут вытеснять другие данные из кэша

```go
// Оптимизированный размер буфера (кратный размеру кэш-линии)
const bufferSize = 4096 // 64 * 64 = 4096 байт
buffer := make([]byte, bufferSize)
```

## Учитывайте размер строки кэша при проектировании структур данных

### Почему это важно
Структуры данных, спроектированные с учетом размера строки кэша, более эффективно используют кэш процессора.

### Рекомендации
- **Размер структур**: стремитесь, чтобы часто используемые структуры помещались в одну строку кэша
- **Выравнивание данных**: размещайте часто используемые поля в начале структуры
- **Секционирование данных**: разделяйте данные, к которым обращаются разные потоки

```go
// Структура, оптимизированная для кэша
type CacheOptimizedNode struct {
    // Самые часто используемые поля (горячие)
    Counter  uint64
    IsActive bool
    
    // Редко используемые поля (холодные)
    Description string
    Metadata    map[string]interface{}
}

// Для крупных структур данных используйте шардирование
type ShardedMap struct {
    shards [256]struct {
        data map[string]interface{}
        mu   sync.RWMutex
        // padding до размера кэш-линии
        _ [40]byte // дополнение до 64 байт
    }
}
```

---

# Другие оптимизации в Go (не связанные с кэшем)

## 1. Оптимизации выделения памяти и сборки мусора

- **Переиспользуйте объекты** через пул объектов:
  ```go
  var bufferPool = sync.Pool{
      New: func() interface{} {
          return new(bytes.Buffer)
      },
  }
  ```

- **Применяйте escape-анализ** для уменьшения выделений в куче:
  ```go
  // Переменная allocatedOnStack не "убежит" в кучу
  func example() int {
      allocatedOnStack := 42
      return allocatedOnStack
  }
  ```

- **Настройте сборщик мусора** для приложений с особыми требованиями:
  ```go
  import "runtime/debug"
  
  func init() {
      debug.SetGCPercent(100) // По умолчанию
      debug.SetMaxStack(32 * 1024 * 1024)
  }
  ```

## 2. Оптимизации конкурентности

- **Используйте воркер-пулы** для управления параллелизмом:
  ```go
  func worker(jobChan <-chan Job, results chan<- Result) {
      for job := range jobChan {
          results <- process(job)
      }
  }
  ```

- **Применяйте буферизованные каналы** для уменьшения блокировок:
  ```go
  // Буферизованный канал уменьшает синхронизационные накладные расходы
  ch := make(chan Task, 100)
  ```

- **Используйте атомарные операции** вместо мьютексов, где возможно:
  ```go
  import "sync/atomic"
  
  var counter int64
  atomic.AddInt64(&counter, 1)
  ```

## 3. Оптимизации компиляции

- **Используйте встраивание функций** с помощью `//go:inline`:
  ```go
  //go:inline
  func add(a, b int) int {
      return a + b
  }
  ```

- **Избегайте интерфейсов**, когда производительность критична:
  ```go
  // Более производительно для часто вызываемых функций
  func ProcessInt(x int) {}
  
  // Менее эффективно из-за проверок типов
  func ProcessInterface(x interface{}) {}
  ```

- **Используйте режимы компиляции** для оптимизаций:
  ```bash
  go build -gcflags="-B" # Отключает bounds checking
  ```

## 4. Оптимизации ввода-вывода

- **Используйте буферизованный ввод-вывод**:
  ```go
  reader := bufio.NewReader(os.Stdin)
  writer := bufio.NewWriter(os.Stdout)
  defer writer.Flush()
  ```

- **Применяйте пулинг соединений** для сетевых операций:
  ```go
  transport := &http.Transport{
      MaxIdleConns:        100,
      MaxIdleConnsPerHost: 100,
  }
  ```

- **Используйте `io.Copy` для перемещения данных**:
  ```go
  io.Copy(dst, src) // Оптимизированное копирование между io.Reader и io.Writer
  ```

## 5. Оптимизации алгоритмов и структур данных

- **Выбирайте правильные структуры данных**:
  ```go
  // map для O(1) поиска
  lookupTable := make(map[string]int)
  
  // slice для последовательного доступа
  items := make([]Item, 0, estimatedSize)
  ```

- **Предварительно выделяйте память для слайсов**:
  ```go
  // Предотвращает многократные перевыделения
  result := make([]int, 0, len(input))
  ```

- **Используйте специализированные алгоритмы**:
  ```go
  // Для поиска в отсортированном массиве
  index := sort.Search(len(sortedData), func(i int) bool {
      return sortedData[i] >= target
  })
  ```

## 6. Оптимизации рефлексии и сериализации

- **Избегайте рефлексии** там, где возможно:
  ```go
  // Вместо reflection.DeepEqual используйте специализированное сравнение
  func AreEqual(a, b MyStruct) bool {
      return a.Field1 == b.Field1 && a.Field2 == b.Field2
  }
  ```

- **Используйте генерацию кода** вместо рефлексии:
  ```go
  //go:generate stringer -type=Enum
  type Enum int
  ```

- **Выбирайте эффективные форматы сериализации**:
  ```go
  // Более эффективно чем JSON для внутренних коммуникаций
  import "google.golang.org/protobuf/proto"
  ```

## 7. Инструментарий и метрики

- **Используйте встроенные профилировщики**:
  ```go
  import _ "net/http/pprof"
  
  func main() {
      go http.ListenAndServe(":6060", nil)
      // ...
  }
  ```

- **Применяйте трассировку** для анализа конкурентности:
  ```go
  import "runtime/trace"
  
  func main() {
      f, _ := os.Create("trace.out")
      defer f.Close()
      trace.Start(f)
      defer trace.Stop()
      // ...
  }
  ```

- **Анализируйте использование памяти**:
  ```bash
  go test -benchmem -bench=.
  ```

## 8. Архитектурные оптимизации

- **Используйте пакетную обработку** вместо поштучной:
  ```go
  // Обработка пакетами снижает накладные расходы
  ProcessBatch(items) // Вместо items.forEach(Process)
  ```

- **Применяйте кэширование результатов**:
  ```go
  // Простой кэш с TTL
  type Cache struct {
      data map[string]cacheItem
      mu   sync.RWMutex
  }
  
  type cacheItem struct {
      value      interface{}
      expiration time.Time
  }
  ```

- **Используйте шардирование данных** для масштабирования:
  ```go
  type ShardedMap struct {
      shards    [256]Shard
      hashFunc  func(key string) uint8
  }
  
  type Shard struct {
      items map[string]interface{}
      mu    sync.RWMutex
  }
  ```

- **Проектируйте с учетом локальности данных**:
  ```go
  // Группировка связанных данных в один сервис
  // Минимизация сетевых запросов между сервисами
  ```

## 9. Оптимизации строк и текста

- **Используйте strings.Builder вместо конкатенации**:
  ```go
  var b strings.Builder
  for i := 0; i < 1000; i++ {
      b.WriteString("a")
  }
  result := b.String()
  ```

- **Применяйте []byte для интенсивной обработки текста**:
  ```go
  data := []byte("text to process")
  // Модификация без выделения новой памяти
  for i := 0; i < len(data); i++ {
      if data[i] == 'a' {
          data[i] = 'b'
      }
  }
  ```

- **Используйте strings.Repeat для повторений**:
  ```go
  // Эффективнее чем цикл с конкатенацией
  padding := strings.Repeat(" ", indent)
  ```

## 10. Системные оптимизации

- **Настройте ulimit для высоконагруженных серверов**:
  ```bash
  ulimit -n 65535  # Увеличение максимального числа открытых файлов
  ```

- **Используйте SO_REUSEPORT для балансировки нагрузки**:
  ```go
  import "golang.org/x/sys/unix"
  
  ln, _ := net.Listen("tcp", ":8080")
  file, _ := ln.(*net.TCPListener).File()
  
  unix.SetsockoptInt(int(file.Fd()), unix.SOL_SOCKET, unix.SO_REUSEPORT, 1)
  ```

- **Применяйте механизм передачи файловых дескрипторов**:
  ```go
  // Для обновлений без простоя
  import "github.com/cloudflare/tableflip"
  
  upg, _ := tableflip.New(tableflip.Options{})
  defer upg.Stop()
  ```

## 11. Сетевые оптимизации

- **Управляйте кипами соединений (keep-alive)**:
  ```go
  client := &http.Client{
      Transport: &http.Transport{
          IdleConnTimeout: 90 * time.Second,
          DialContext: (&net.Dialer{
              Timeout:   30 * time.Second,
              KeepAlive: 30 * time.Second,
          }).DialContext,
      },
  }
  ```

- **Используйте HTTP/2 и мультиплексирование**:
  ```go
  server := &http.Server{
      Addr:    ":8080",
      Handler: handler,
  }
  // HTTP/2 включен по умолчанию для HTTPS
  ```

- **Применяйте сжатие данных**:
  ```go
  import "github.com/gin-contrib/gzip"
  
  r := gin.Default()
  r.Use(gzip.Gzip(gzip.DefaultCompression))
  ```

## 12. Оптимизации компилятора и сборки

- **Используйте директивы CGO**:
  ```go
  // Отключение CGO для статической компиляции
  // CGO_ENABLED=0 go build
  ```

- **Применяйте линкер-флаги для уменьшения размера бинарника**:
  ```bash
  go build -ldflags="-s -w" # Удаляет отладочную информацию
  ```

- **Используйте тримминг зависимостей**:
  ```go
  // go.mod
  go 1.16
  
  require (
      github.com/example/pkg v1.0.0
  )
  
  // go mod tidy
  ```

## 13. Оптимизации для специфических доменов

- **Обработка изображений и мультимедиа**:
  ```go
  import "github.com/disintegration/imaging"
  
  // Эффективная обработка изображений
  dstImage := imaging.Resize(srcImage, width, height, imaging.Lanczos)
  ```

- **Обработка больших данных**:
  ```go
  // Потоковая обработка данных без загрузки всего в память
  scanner := bufio.NewScanner(file)
  for scanner.Scan() {
      processLine(scanner.Text())
  }
  ```

- **Микросервисные оптимизации**:
  ```go
  // Распределение нагрузки между сервисами
  // Асинхронная обработка событий
  // Circuit breaker для предотвращения каскадных отказов
  import "github.com/sony/gobreaker"
  ```

## 14. Процедурно-специфические оптимизации

- **Использование SIMD через cgo**:
  ```go
  // Вызов оптимизированного C/C++ кода с AVX/SSE инструкциями
  /*
  #cgo CFLAGS: -mavx2
  #include <immintrin.h>
  void vector_add(float* a, float* b, float* c, int len);
  */
  import "C"
  ```

- **Применение специализированных библиотек**:
  ```go
  import "gonum.org/v1/gonum/mat"
  
  // Оптимизированные математические операции
  a := mat.NewDense(3, 3, nil)
  b := mat.NewDense(3, 3, nil)
  var c mat.Dense
  c.Mul(a, b)
  ```

- **Использование unsafe для низкоуровневой оптимизации**:
  ```go
  import "unsafe"
  
  // Преобразование типов без выделения памяти
  bytes := *(*[]byte)(unsafe.Pointer(
      &reflect.SliceHeader{
          Data: uintptr(unsafe.Pointer(&s[0])),
          Len:  len(s),
          Cap:  len(s),
      },
  ))
  ```

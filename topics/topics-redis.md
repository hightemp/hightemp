### **1. Основы Redis**

*   **1.1. Введение в Redis:**
    *   Что такое Redis и для чего он используется?
    *   Отличия Redis от реляционных СУБД и других NoSQL баз данных.
    *   Преимущества и недостатки Redis.
    *   Основные варианты использования Redis (кэширование, очереди сообщений, сессии, лидерборды и т.д.).
    *   История развития Redis.
    *   Ключевые концепции: ключ-значение, структуры данных, персистентность, репликация, кластеризация.
*   **1.2. Установка и настройка:**
    *   Установка Redis на различные операционные системы (Linux, macOS, Windows).
    *   Основные конфигурационные параметры в `redis.conf` и их влияние на производительность и поведение.
        *   `port`: порт, на котором слушает Redis.
        *   `bind`: IP-адреса, на которых Redis будет принимать соединения.
        *   `requirepass`: пароль для аутентификации.
        *   `maxmemory`: ограничение памяти, используемой Redis.
        *   `maxmemory-policy`: политика вытеснения данных при достижении `maxmemory`.
        *   `appendonly`: включение/выключение AOF (Append Only File) для персистентности.
        *   `save`: настройки RDB (Redis Database) для персистентности.
    *   Запуск и остановка сервера Redis.
    *   Подключение к серверу Redis с помощью `redis-cli`.
*   **1.3. Команды Redis:**
    *   Основные команды для работы с ключами (SET, GET, DEL, EXISTS, KEYS, TTL, EXPIRE, PERSIST).
    *   Команды для работы со строками (APPEND, STRLEN, GETRANGE, SETRANGE).
    *   Команды для работы со списками (LPUSH, RPUSH, LPOP, RPOP, LINDEX, LRANGE, LLEN, LTRIM).
    *   Команды для работы с множествами (SADD, SREM, SMEMBERS, SISMEMBER, SCARD, SUNION, SINTER, SDIFF).
    *   Команды для работы с упорядоченными множествами (ZADD, ZREM, ZRANGE, ZREVRANGE, ZCARD, ZSCORE, ZRANK, ZREVRANK).
    *   Команды для работы с хешами (HSET, HGET, HDEL, HKEYS, HVALS, HGETALL, HEXISTS).
    *   Команды для работы с битовыми массивами (SETBIT, GETBIT, BITCOUNT, BITOP).
    *   Команды для работы с HyperLogLog (PFADD, PFCOUNT, PFMERGE).
    *   Команды для работы с Geospatial indexes (GEOADD, GEODIST, GEORADIUS, GEORADIUSBYMEMBER).
    *   Команды для работы с потоками (XADD, XREAD, XRANGE, XREVRANGE, XGROUP, XACK).
*   **1.4. Клиентские библиотеки:**
    *   Обзор популярных клиентских библиотек для различных языков программирования (Python, Java, Node.js, Ruby, Go, PHP, C#, C++).
    *   Подключение к серверу Redis из кода.
    *   Выполнение команд Redis с использованием клиентских библиотек.
    *   Обработка ошибок и исключений.

### **2. Структуры данных**

*   **2.1. Строки (Strings):**
    *   Внутреннее представление строк в Redis.
    *   Особенности использования строк для хранения бинарных данных.
    *   Примеры использования строк: кэширование, счетчики, хранение JSON.
*   **2.2. Списки (Lists):**
    *   Внутреннее представление списков в Redis.
    *   Особенности использования списков для реализации очередей, стеков, логов.
    *   Блокирующие операции со списками (BLPOP, BRPOP, BRPOPLPUSH).
*   **2.3. Множества (Sets):**
    *   Внутреннее представление множеств в Redis.
    *   Особенности использования множеств для хранения уникальных значений.
    *   Операции над множествами: объединение, пересечение, разность.
    *   Примеры использования множеств: отслеживание уникальных посетителей, теги, рекомендации.
*   **2.4. Упорядоченные множества (Sorted Sets):**
    *   Внутреннее представление упорядоченных множеств в Redis.
    *   Особенности использования упорядоченных множеств для хранения элементов с весами (score).
    *   Примеры использования упорядоченных множеств: лидерборды, рейтинги, индексация по времени.
*   **2.5. Хеши (Hashes):**
    *   Внутреннее представление хешей в Redis.
    *   Особенности использования хешей для хранения объектов.
    *   Примеры использования хешей: профили пользователей, корзины покупок.
*   **2.6. Битовые массивы (Bitmaps):**
    *   Внутреннее представление битовых массивов в Redis.
    *   Особенности использования битовых массивов для хранения битовых флагов.
    *   Примеры использования битовых массивов: статистика активных пользователей, фильтры Блума.
*   **2.7. HyperLogLog:**
    *   Внутреннее представление HyperLogLog в Redis.
    *   Особенности использования HyperLogLog для оценки количества уникальных элементов с погрешностью.
    *   Примеры использования HyperLogLog: подсчет уникальных просмотров, анализ трафика.
*   **2.8. Geospatial Indexes:**
    *   Внутреннее представление Geospatial Indexes в Redis.
    *   Особенности использования Geospatial Indexes для хранения геопространственных данных.
    *   Примеры использования Geospatial Indexes: поиск объектов поблизости, расчет расстояний.
*   **2.9. Потоки (Streams):**
    *   Внутреннее представление потоков в Redis.
    *   Особенности использования потоков для хранения последовательности сообщений.
    *   Потребительские группы и их использование для распределенной обработки потоков.
    *   Примеры использования потоков: ленты событий, логгирование, чаты.

### **3. Продвинутые возможности**

*   **3.1. Транзакции:**
    *   Команды MULTI, EXEC, DISCARD, WATCH.
    *   Обеспечение атомарности операций.
    *   Оптимистическая блокировка с помощью WATCH.
    *   Особенности использования транзакций в Redis.
    *   Сравнение транзакций Redis с транзакциями в реляционных СУБД.
*   **3.2. Pub/Sub (Публикация/Подписка):**
    *   Команды PUBLISH, SUBSCRIBE, UNSUBSCRIBE, PSUBSCRIBE, PUNSUBSCRIBE.
    *   Реализация паттерна "издатель-подписчик".
    *   Особенности использования Pub/Sub в Redis.
    *   Сравнение Pub/Sub с очередями сообщений.
*   **3.3. Lua скрипты:**
    *   Команды EVAL, EVALSHA, SCRIPT LOAD, SCRIPT EXISTS, SCRIPT FLUSH, SCRIPT KILL.
    *   Выполнение атомарных операций с помощью Lua скриптов.
    *   Преимущества использования Lua скриптов: атомарность, уменьшение сетевого трафика, возможность переиспользования кода.
    *   Особенности написания и отладки Lua скриптов для Redis.
*   **3.4. Модули:**
    *   Что такое модули Redis и зачем они нужны?
    *   Загрузка и выгрузка модулей.
    *   Обзор популярных модулей: RedisJSON, RedisGraph, RedisSearch, RediSearch, RedisBloom, RedisTimeSeries.
    *   Разработка собственных модулей на C/C++.
*   **3.5. Redis Gears:**
    *   Что такое Redis Gears и зачем он нужен?
    *   Основные концепции: функции, операции, регистрации.
    *   Реализация распределенных вычислений с помощью Redis Gears.
    *   Примеры использования Redis Gears: обработка потоков данных, ETL.
*   **3.6. Redis Functions (новое в Redis 7.0):**
    *   Что такое Redis Functions и как они отличаются от Lua скриптов и модулей?
    *   Создание и вызов функций.
    *   Управление библиотеками функций.

### **4. Персистентность и надежность**

*   **4.1. RDB (Redis Database):**
    *   Механизм создания снимков данных.
    *   Настройка RDB в `redis.conf` (параметры `save`).
    *   Преимущества и недостатки RDB.
    *   Влияние RDB на производительность.
*   **4.2. AOF (Append Only File):**
    *   Механизм журналирования команд.
    *   Настройка AOF в `redis.conf` (параметры `appendonly`, `appendfsync`).
    *   Перезапись AOF файла (команда BGREWRITEAOF).
    *   Преимущества и недостатки AOF.
    *   Влияние AOF на производительность.
*   **4.3. Выбор стратегии персистентности:**
    *   Сравнение RDB и AOF.
    *   Комбинирование RDB и AOF.
    *   Рекомендации по выбору стратегии персистентности в зависимости от требований к надежности и производительности.
*   **4.4. Репликация:**
    *   Настройка репликации master-slave.
    *   Команды SLAVEOF, REPLICAOF, ROLE.
    *   Механизм синхронизации данных между мастером и репликами.
    *   Автоматическое переключение на реплику при сбое мастера.
    *   Использование реплик для масштабирования чтения.
*   **4.5. Redis Sentinel:**
    *   Мониторинг экземпляров Redis.
    *   Автоматическое переключение на реплику при сбое мастера (failover).
    *   Настройка Redis Sentinel.
    *   Взаимодействие клиентских приложений с Redis Sentinel.
*   **4.6. Redis Cluster:**
    *   Автоматическое шардирование данных.
    *   Распределение данных по нескольким узлам.
    *   Механизм перераспределения данных (resharding).
    *   Настройка Redis Cluster.
    *   Взаимодействие клиентских приложений с Redis Cluster.
    *   Обеспечение высокой доступности и масштабируемости.
    *   Миграция в Redis Cluster из одиночного сервера или Sentinel.

### **5. Мониторинг и отладка**

*   **5.1. Команда INFO:**
    *   Получение информации о состоянии сервера Redis.
    *   Анализ метрик производительности.
*   **5.2. Команда MONITOR:**
    *   Мониторинг команд, выполняемых на сервере Redis в режиме реального времени.
    *   Отладка приложений, использующих Redis.
*   **5.3. Slowlog:**
    *   Отслеживание медленных команд.
    *   Настройка slowlog в `redis.conf`.
    *   Анализ slowlog с помощью команды SLOWLOG GET.
*   **5.4. Latency Monitoring:**
    *   Отслеживание задержек (latency) при выполнении команд Redis.
    *   Команды LATENCY LATEST, LATENCY HISTORY, LATENCY GRAPH, LATENCY DOCTOR.
    *   Анализ причин возникновения задержек.
*   **5.5. Redis-benchmark:**
    *   Тестирование производительности Redis.
    *   Измерение пропускной способности и времени отклика.
    *   Использование redis-benchmark для оценки влияния различных настроек на производительность.
*   **5.6. Внешние инструменты:**
    *   Использование систем мониторинга (Prometheus, Grafana, Datadog) для сбора и визуализации метрик Redis.
    *   Инструменты для анализа дампов RDB файлов.

### **6. Безопасность**

*   **6.1. Аутентификация:**
    *   Настройка пароля с помощью параметра `requirepass` в `redis.conf`.
    *   Команда AUTH.
    *   Использование ACL (Access Control Lists) для управления доступом к командам и ключам (начиная с Redis 6.0).
*   **6.2. Сетевая безопасность:**
    *   Ограничение доступа к серверу Redis с помощью брандмауэра.
    *   Использование параметра `bind` для ограничения сетевых интерфейсов, на которых слушает Redis.
    *   Настройка TLS/SSL шифрования для защиты данных, передаваемых по сети.
*   **6.3. Безопасность данных:**
    *   Ограничение доступа к конфигурационному файлу и директории с данными.
    *   Регулярное резервное копирование данных.
    *   Ограничение использования команд, которые могут привести к утечке данных (KEYS, FLUSHALL, FLUSHDB).

### **7. Масштабирование**

*   **7.1. Вертикальное масштабирование:**
    *   Увеличение ресурсов сервера (CPU, RAM, диск).
    *   Оптимизация настроек Redis для использования доступных ресурсов.
*   **7.2. Горизонтальное масштабирование:**
    *   Использование репликации для масштабирования чтения.
    *   Использование Redis Cluster для масштабирования записи и чтения.
*   **7.3. Шардирование на стороне приложения:**
    *   Разделение данных по нескольким экземплярам Redis.
    *   Реализация логики шардирования в клиентском приложении.
    *   Использование консистентного хеширования для распределения ключей по шардам.
*   **7.4. Прокси:**
    *   Использование прокси (Twemproxy, Envoy) для распределения нагрузки между несколькими экземплярами Redis.
    *   Реализация логики шардирования на уровне прокси.

### **8. Интеграция с другими системами**

*   **8.1. Кэширование:**
    *   Использование Redis в качестве кэша для веб-приложений, баз данных, API.
    *   Стратегии инвалидации кэша.
*   **8.2. Очереди сообщений:**
    *   Использование Redis в качестве брокера сообщений (Message Broker).
    *   Реализация асинхронной обработки задач.
    *   Интеграция с системами очередей сообщений (RabbitMQ, Kafka).
*   **8.3. Базы данных:**
    *   Использование Redis в качестве основной базы данных для определенных типов приложений (игры, чаты, системы реального времени).
    *   Интеграция Redis с реляционными СУБД (MySQL, PostgreSQL) и другими NoSQL базами данных (MongoDB, Cassandra).

### **9. Производительность и оптимизация**

*   **9.1. Оптимизация использования памяти:**
    *   Выбор подходящих структур данных.
    *   Настройка политики вытеснения данных (`maxmemory-policy`).
    *   Использование пулов соединений.
    *   Использование конвейерной обработки (pipelining).
*   **9.2. Оптимизация производительности:**
    *   Анализ метрик производительности с помощью команды INFO и slowlog.
    *   Использование redis-benchmark для тестирования производительности.
    *   Оптимизация Lua скриптов.
    *   Использование Redis Cluster для распределения нагрузки.
*   **9.3. Оптимизация настроек:**
    *   Тюнинг параметров `redis.conf` для достижения оптимальной производительности.
    *   Оптимизация настроек операционной системы.
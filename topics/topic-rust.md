**План Глубокого Изучения Языка Программирования Rust**

**Раздел 1: Основы и Фундаментальные Концепции**

*   **1.1. Введение и Установка Среды**
    *   **1.1.1. Философия Rust:** Безопасность памяти без сборщика мусора, производительность, параллелизм. Понимание целей создания языка.
    *   **1.1.2. Установка `rustup`:** Управление версиями Rust, тулчейнами (stable, beta, nightly), компонентами (rustc, cargo, rustfmt, clippy, rust-docs).
    *   **1.1.3. "Hello, World!" и Структура Проекта:**
        *   `cargo new <project_name>`: Создание бинарного проекта.
        *   `cargo new --lib <library_name>`: Создание библиотечного проекта.
        *   Файл `Cargo.toml`: Манифест проекта (метаданные, зависимости).
        *   Файл `src/main.rs` / `src/lib.rs`: Точки входа.
        *   Функция `main()`.
        *   Макрос `println!`.
    *   **1.1.4. Основы `cargo`:**
        *   `cargo build`: Компиляция проекта (без оптимизаций).
        *   `cargo build --release`: Компиляция с оптимизациями.
        *   `cargo run`: Компиляция и запуск бинарного проекта.
        *   `cargo check`: Быстрая проверка кода без генерации исполняемого файла.
        *   `cargo update`: Обновление зависимостей.
        *   `target/` директория: Артефакты сборки.
    *   **1.1.5. Интеграция с IDE/Редактором:** Настройка `rust-analyzer` (или аналога) для автодополнения, подсветки ошибок, форматирования.

*   **1.2. Базовый Синтаксис и Типы Данных**
    *   **1.2.1. Переменные и Мутабельность:**
        *   `let`: Объявление неизменяемых переменных.
        *   `let mut`: Объявление изменяемых переменных.
        *   Затенение (Shadowing): Переопределение переменной с тем же именем.
        *   Константы (`const`): Всегда неизменяемые, вычисляются во время компиляции, требуют аннотации типа.
        *   Статические переменные (`static`): Глобальные переменные с фиксированным адресом в памяти (`'static` lifetime), могут быть изменяемыми (требует `unsafe`).
    *   **1.2.2. Скалярные Типы Данных:**
        *   Целочисленные (`i8`, `u8`, `i16`, `u16`, `i32`, `u32`, `i64`, `u64`, `i128`, `u128`, `isize`, `usize`): Знаковые/беззнаковые, размеры, платформозависимые типы. Литералы (десятичные, шестнадцатеричные, восьмеричные, бинарные, с разделителями `_`). Переполнение (поведение в debug/release).
        *   Числа с плавающей точкой (`f32`, `f64`): Стандарт IEEE-754. Литералы. Особенности сравнения.
        *   Булев тип (`bool`): `true`, `false`.
        *   Символьный тип (`char`): Unicode скалярное значение (4 байта). Литералы (`'a'`, `'\u{1F600}'`).
    *   **1.2.3. Составные Типы Данных:**
        *   Кортежи (`tuple`): Фиксированный размер, элементы разных типов. Создание, деструктуризация, доступ по индексу (`.0`, `.1`, ...).
        *   Массивы (`array`): Фиксированный размер, элементы одного типа. Хранение на стеке. Литералы (`[1, 2, 3]`, `[0; 5]`). Доступ по индексу (`arr[0]`). Выход за границы (паника в debug, неопределенное поведение в release без проверок, но Rust обычно вставляет проверки).
    *   **1.2.4. Функции:**
        *   Определение (`fn name(param: Type) -> ReturnType { ... }`).
        *   Параметры и аргументы.
        *   Возвращаемые значения (явный `return` или значение последнего выражения).
        *   Выражения (`expression`) vs Инструкции (`statement`): Ключевое различие в Rust. Тело функции как блок-выражение.
        *   Расходящиеся функции (`diverging functions`): Функции, которые никогда не возвращают управление (`panic!`, `loop {}`), тип `!`.
    *   **1.2.5. Комментарии:**
        *   Однострочные (`//`).
        *   Многострочные (`/* ... */`).
        *   Документационные (`///` для элементов, `//!` для модуля/крейта). Генерация документации (`cargo doc --open`).
    *   **1.2.6. Управляющие Конструкции:**
        *   `if`/`else`/`else if`: Условия. `if` как выражение.
        *   `loop`: Бесконечный цикл. `break` (с возвратом значения), `continue`. Метки циклов (`'label: loop { break 'label value; }`).
        *   `while`: Цикл с предусловием.
        *   `for`: Цикл по итерируемому объекту (диапазоны `1..5`, `1..=5`, итераторы коллекций).

**Раздел 2: Владение, Заимствование и Время Жизни (Ключевые Концепции Rust)**

*   **2.1. Система Владения (Ownership)**
    *   **2.1.1. Проблема Управления Памятью:** Стековая и кучная память. Утечки памяти, двойное освобождение, висячие указатели в C/C++. Сборка мусора и её издержки.
    *   **2.1.2. Три Правила Владения:**
        *   Каждое значение имеет *владельца*.
        *   В каждый момент времени может быть только *один* владелец.
        *   Когда владелец выходит из области видимости, значение *удаляется* (`drop` вызывается).
    *   **2.1.3. Перемещение Владения (Move Semantics):** Присваивание, передача в функцию, возврат из функции для типов из кучи (например, `String`, `Vec<T>`, `Box<T>`). Невалидность старого владельца.
    *   **2.1.4. Клонирование (Clone):** Трейт `Clone`. Глубокое копирование данных. `clone()`. Когда использовать `clone`.
    *   **2.1.5. Копирование (Copy):** Трейт `Copy`. Неявное "копирование" для простых типов со стека (скалярные типы, кортежи/массивы простых типов). Отсутствие перемещения. Условие реализации `Copy` (все поля должны реализовывать `Copy`).
    *   **2.1.6. Владение и Функции:** Передача владения аргументам, возврат владения из функции.

*   **2.2. Ссылки и Заимствование (Borrowing)**
    *   **2.2.1. Неизменяемые Ссылки (`&T`):** Заимствование без передачи владения. Позволяют читать данные.
    *   **2.2.2. Изменяемые Ссылки (`&mut T`):** Позволяют читать и изменять данные.
    *   **2.2.3. Правила Заимствования (Проверяются Компилятором):**
        *   В любой момент времени может существовать либо *одна* изменяемая ссылка, *либо* *любое количество* неизменяемых ссылок на конкретные данные в конкретной области видимости.
        *   Ссылки должны быть валидны (не могут указывать на освобожденную память).
    *   **2.2.4. Разыменование Ссылок:** Оператор `*`.
    *   **2.2.5. Предотвращение Висячих Ссылок (Dangling References):** Как система владения и правила заимствования гарантируют отсутствие висячих ссылок во время компиляции.

*   **2.3. Срезы (Slices)**
    *   **2.3.1. Концепция Среза:** Представление непрерывной последовательности элементов в коллекции без владения самой коллекцией.
    *   **2.3.2. Строковые Срезы (`&str`):** Срез `String` или строкового литерала. Неизменяемый.
    *   **2.3.3. Срезы Массивов/Векторов (`&[T]`, `&mut [T]`):** Ссылки на часть массива или вектора.
    *   **2.3.4. Безопасность Срезов:** Связь с правилами заимствования.

*   **2.4. Время Жизни (Lifetimes)**
    *   **2.4.1. Проблема:** Гарантия того, что ссылки не "переживут" данные, на которые они указывают. Особенно актуально для функций, возвращающих ссылки, и структур, хранящих ссылки.
    *   **2.4.2. Аннотации Времени Жизни (Syntax):** Апостроф (`'a`, `'b`, `'static`). Указание взаимосвязи между временами жизни разных ссылок.
    *   **2.4.3. Времена Жизни в Сигнатурах Функций:** Аннотирование параметров-ссылок и возвращаемых ссылок.
    *   **2.4.4. Правила Элизии Времен Жизни (Lifetime Elision Rules):** Случаи, когда компилятор может вывести времена жизни автоматически (три основных правила).
    *   **2.4.5. Времена Жизни в Определениях Структур (`struct`):** Когда структура хранит ссылки, ей необходимы аннотации времени жизни.
    *   **2.4.6. Статическое Время Жизни (`'static`):** Ссылки, которые валидны в течение всей работы программы (строковые литералы, статические переменные).
    *   **2.4.7. Ограничения Времени Жизни (Lifetime Bounds):** Указание, что одно время жизни должно быть как минимум таким же долгим, как другое (`'a: 'b`).
    *   **2.4.8. Времена жизни и Дженерики/Трейты.**

**Раздел 3: Структуры Данных и Перечисления**

*   **3.1. Структуры (`struct`)**
    *   **3.1.1. Определение Структур:** С именованными полями.
    *   **3.1.2. Создание Экземпляров:** Синтаксис `StructName { field1: value1, ... }`. Сокращенный синтаксис инициализации полей.
    *   **3.1.3. Доступ к Полям:** Через точку (`instance.field`).
    *   **3.1.4. Обновление Экземпляров:** Синтаксис `..other_instance` для копирования оставшихся полей.
    *   **3.1.5. Кортежные Структуры (`Tuple Structs`):** `struct Color(i32, i32, i32);`.
    *   **3.1.6. Юнит-подобные Структуры (`Unit-like Structs`):** Без полей, полезны для реализации трейтов. `struct AlwaysEqual;`.
    *   **3.1.7. Владение Данными в Структурах:** Поля структуры подчиняются правилам владения.
    *   **3.1.8. Методы Структур (`impl`):**
        *   Блок `impl StructName { ... }`.
        *   Методы (`&self`, `&mut self`, `self`): Первый параметр определяет, как метод взаимодействует с экземпляром (заимствует неизменяемо, заимствует изменяемо, забирает владение).
        *   Ассоциированные Функции (Associated Functions): Функции внутри `impl`, не принимающие `self` (например, конструкторы `StructName::new()`).

*   **3.2. Перечисления (`enum`)**
    *   **3.2.1. Определение Перечислений:** Задание набора возможных вариантов (variants).
    *   **3.2.2. Варианты Перечислений:** Могут быть без данных, с данными (как кортежные структуры или структуры с именованными полями).
    *   **3.2.3. Создание Экземпляров:** `EnumName::VariantName`, `EnumName::VariantWithData(value)`.
    *   **3.2.4. Сопоставление с Образцом (`match`):**
        *   Мощный инструмент для работы с `enum`.
        *   Исчерпываемость (`exhaustive`): `match` должен покрывать все возможные варианты.
        *   Паттерны: Литералы, переменные, `_` (wildcard), `|` (or), диапазоны, деструктуризация.
        *   Привязка значений к переменным в паттернах (`@` binding).
        *   Охранники (`match guards`): Дополнительные `if` условия в ветках `match`.
    *   **3.2.5. Конструкция `if let`:** Упрощенный `match` для одного варианта. `else { ... }` необязателен. `while let`.
    *   **3.2.6. Стандартные Перечисления:**
        *   `Option<T>`: Представление возможного отсутствия значения (`Some(T)` или `None`). Методы `unwrap`, `expect`, `is_some`, `is_none`, `map`, `and_then`, etc.
        *   `Result<T, E>`: Представление операции, которая может завершиться успешно (`Ok(T)`) или с ошибкой (`Err(E)`).

**Раздел 4: Коллекции Стандартной Библиотеки**

*   **4.1. Векторы (`Vec<T>`)**
    *   **4.1.1. Концепция:** Динамический массив, хранящий данные одного типа в куче.
    *   **4.1.2. Создание:** `Vec::new()`, макрос `vec![]`.
    *   **4.1.3. Добавление Элементов:** `push()`.
    *   **4.1.4. Доступ к Элементам:** Индексирование `[]` (паникует при выходе за границы), метод `get()` (возвращает `Option<&T>`).
    *   **4.1.5. Итерация:** `for item in &vector`, `for item in &mut vector`, `for item in vector` (забирает владение).
    *   **4.1.6. Владение и Заимствование:** Хранение элементов в векторе, правила заимствования при доступе. Невозможность иметь изменяемую ссылку и другую ссылку (даже неизменяемую) одновременно.
    *   **4.1.7. Другие Методы:** `pop`, `remove`, `insert`, `len`, `capacity`, `with_capacity`, etc.
    *   **4.1.8. Хранение Разных Типов:** Использование `enum` или трейт-объектов (см. далее) для хранения разнотипных данных в векторе.

*   **4.2. Строки (`String` и `&str`)**
    *   **4.2.1. Различия:** `String` - владеющий, изменяемый, UTF-8 буфер в куче. `&str` - заимствованный, неизменяемый срез строки (часто ссылается на `String` или строковый литерал).
    *   **4.2.2. Создание `String`:** `String::new()`, `to_string()` у `&str`, `String::from("...")`.
    *   **4.2.3. Обновление `String`:** `push_str()`, `push()`, `+` (оператор `Add`, забирает владение левым операндом), макрос `format!`.
    *   **4.2.4. Внутреннее Представление:** UTF-8, переменная длина символов.
    *   **4.2.5. Индексирование Строк:** **Нельзя** индексировать строки по `usize` напрямую (из-за UTF-8). Это распространенная ошибка новичков.
    *   **4.2.6. Срезы Строк:** Использование диапазонов `&s[0..4]`. Паника, если срез не попадает на границы символов UTF-8.
    *   **4.2.7. Итерация по Строкам:** Методы `chars()` (итератор по `char`), `bytes()` (итератор по `u8`).

*   **4.3. Хеш-таблицы (`HashMap<K, V>`)**
    *   **4.3.1. Концепция:** Хранение пар ключ-значение. Ключи должны реализовывать трейты `Eq` и `Hash`.
    *   **4.3.2. Создание:** `HashMap::new()`, `collect()` из итератора кортежей.
    *   **4.3.3. Вставка и Доступ:** `insert(key, value)`, `get(&key)` (возвращает `Option<&V>`).
    *   **4.3.4. Владение Ключами и Значениями:** `HashMap` забирает владение ключами и значениями.
    *   **4.3.5. Обновление Значений:** Перезапись при `insert`, метод `entry()` и `or_insert()`.
    *   **4.3.6. Итерация:** `for (key, value) in &map`.
    *   **4.3.7. Хеширование:** Трейт `Hash`. Выбор хеш-функции (по умолчанию SipHash).

*   **4.4. Другие Коллекции:** Краткий обзор `HashSet<T>`, `BTreeMap<K, V>`, `BTreeSet<T>`, `VecDeque<T>` и их основных характеристик/применений.

**Раздел 5: Обработка Ошибок**

*   **5.1. Невосстановимые Ошибки (`panic!`)**
    *   **5.1.1. Макрос `panic!`:** Когда использовать (ошибки программиста, нарушение инвариантов).
    *   **5.1.2. Разворачивание Стека (Unwinding) vs Прерывание (Abort):** Настройка в `Cargo.toml`.
    *   **5.1.3. Перехват Паники (`catch_unwind`):** Обычно не рекомендуется в прикладном коде.
    *   **5.1.4. Обратные Трассировки (Backtraces):** Переменная окружения `RUST_BACKTRACE`.

*   **5.2. Восстановимые Ошибки (`Result<T, E>`)**
    *   **5.2.1. Перечисление `Result`:** `Ok(T)` для успеха, `Err(E)` для ошибки.
    *   **5.2.2. Обработка `Result` через `match`**.
    *   **5.2.3. Методы `Result`:** `unwrap()`, `expect()` (паникуют при `Err`), `is_ok()`, `is_err()`, `ok()`, `err()`, `map()`, `map_err()`, `and_then()`, etc.
    *   **5.2.4. Оператор Вопросительного Знака (`?`):**
        *   Пропагация (распространение) ошибок вверх по стеку вызовов.
        *   Работает только в функциях, возвращающих `Result` или `Option`.
        *   Автоматически конвертирует типы ошибок (через трейт `From`).
    *   **5.2.5. Определение Собственных Типов Ошибок:** Использование `struct` или `enum` для представления различных видов ошибок. Реализация трейтов `Error`, `Debug`, `Display`.
    *   **5.2.6. Библиотеки для Упрощения Работы с Ошибками:**
        *   `thiserror`: Для создания кастомных типов ошибок в библиотеках (через `#[derive(Error)]`).
        *   `anyhow`: Для простой обработки ошибок в приложениях (использование `anyhow::Result<T>` и `anyhow::Error`).

**Раздел 6: Дженерики, Трейты и Трейт-Объекты**

*   **6.1. Дженерики (Обобщенное Программирование)**
    *   **6.1.1. Проблема Дублирования Кода.**
    *   **6.1.2. Дженерики в Сигнатурах Функций:** `fn largest<T>(list: &[T]) -> &T { ... }`.
    *   **6.1.3. Дженерики в Определениях Структур:** `struct Point<T> { x: T, y: T }`.
    *   **6.1.4. Дженерики в Определениях Перечислений:** `enum Option<T> { Some(T), None }`.
    *   **6.1.5. Дженерики в Реализациях Методов (`impl`)**: `impl<T> Point<T> { ... }`.
    *   **6.1.6. Мономорфизация (Monomorphization):** Процесс, при котором компилятор генерирует конкретный код для каждого используемого типа дженерика. Влияние на производительность (нет оверхеда во время выполнения).

*   **6.2. Трейты (Traits): Определение Общего Поведения**
    *   **6.2.1. Концепция:** Аналог интерфейсов в других языках. Определение набора методов, которые тип должен реализовать.
    *   **6.2.2. Определение Трейта:** `trait Summary { fn summarize(&self) -> String; }`.
    *   **6.2.3. Реализация Трейта для Типа:** `impl Summary for NewsArticle { ... }`.
    *   **6.2.4. Реализации по Умолчанию (Default Implementations):** Предоставление базовой реализации метода в определении трейта.
    *   **6.2.5. Трейты как Параметры Функций (Trait Bounds):**
        *   `fn notify<T: Summary>(item: &T) { ... }` (короткий синтаксис).
        *   `fn notify<T>(item: &T) where T: Summary { ... }` (синтаксис `where`).
        *   Несколько трейт-баундов: `T: Summary + Display`.
    *   **6.2.6. Использование `impl Trait` в Качестве Типа Параметра/Возвращаемого Значения:** `fn notify(item: &impl Summary)` или `fn returns_summarizable() -> impl Summary`. Упрощает сигнатуры, но имеет ограничения.
    *   **6.2.7. Условная Реализация Методов/Трейтов:** `impl<T: Display + PartialOrd> Pair<T> { ... }`.
    *   **6.2.8. Производные Трейты (`derive`):** Автоматическая реализация стандартных трейтов (`Debug`, `Clone`, `Copy`, `PartialEq`, `Eq`, `PartialOrd`, `Ord`, `Hash`, `Default`).
    *   **6.2.9. Правило Сироты (Orphan Rule):** Трейт или тип (или оба) должны быть определены локально в текущем крейте для возможности реализации трейта для типа.
    *   **6.2.10. Маркерные Трейты (Marker Traits):** Трейты без методов, указывающие на определенные свойства типа (`Send`, `Sync`, `Copy`, `Sized`).

*   **6.3. Трейт-Объекты (Trait Objects): Динамическая Диспетчеризация**
    *   **6.3.1. Проблема:** Необходимость работать с коллекцией объектов разных типов, реализующих один и тот же трейт, когда конкретные типы неизвестны во время компиляции.
    *   **6.3.2. Динамическая vs Статическая Диспетчеризация:** Отличия, производительность.
    *   **6.3.3. Создание Трейт-Объектов:** Использование указателей (`&dyn Trait`, `Box<dyn Trait>`, `Rc<dyn Trait>`, `Arc<dyn Trait>`). Ключевое слово `dyn`.
    *   **6.3.4. Ограничения Трейт-Объектов (Object Safety):** Не все трейты могут быть использованы для создания трейт-объектов (например, если трейт требует `Self: Sized` или возвращает `Self`).
    *   **6.3.5. Использование:** Хранение разнотипных объектов в `Vec<Box<dyn Trait>>`.

*   **6.4. Ассоциированные Типы (Associated Types)**
    *   **6.4.1. Проблема:** Связывание типа-плейсхолдера с трейтом так, что реализация трейта определяет конкретный тип.
    *   **6.4.2. Определение и Использование:** Пример трейта `Iterator` с ассоциированным типом `Item`.
    *   **6.4.3. Отличие от Дженериков в Трейтах:** Дженерик позволяет реализовать трейт для типа несколько раз с разными параметрами, ассоциированный тип фиксируется один раз для конкретной реализации.

*   **6.5. Перегрузка Операторов (Operator Overloading):** Реализация стандартных трейтов из `std::ops` (`Add`, `Sub`, `Mul`, `Div`, `Index`, `Deref`, etc.).

**Раздел 7: Модули, Крейты и Рабочие Области**

*   **7.1. Пакеты и Крейты (Packages and Crates)**
    *   **7.1.1. Крейт:** Единица компиляции (библиотека или исполняемый файл).
    *   **7.1.2. Пакет:** Один или несколько крейтов, предоставляющих набор функциональности. Содержит `Cargo.toml`. Пакет может содержать не более одной библиотеки, но любое количество бинарных крейтов.
    *   **7.1.3. Корень Крейта:** `src/main.rs` (для бинарного) или `src/lib.rs` (для библиотечного).

*   **7.2. Модульная Система (Modules)**
    *   **7.2.1. Цель:** Организация кода, контроль области видимости и приватности.
    *   **7.2.2. Определение Модулей:** Ключевое слово `mod`. Вложенные модули.
    *   **7.2.3. Пути (Paths):** Абсолютные (`crate::...`) и относительные (`self::...`, `super::...`).
    *   **7.2.4. Приватность:** По умолчанию все элементы (функции, структуры, поля структур, енумы, модули) приватны.
    *   **7.2.5. Публичный Доступ (`pub`):** Сделать элемент видимым вне модуля.
    *   **7.2.6. Ограниченная Видимость:** `pub(crate)`, `pub(super)`, `pub(in path)`.
    *   **7.2.7. Ключевое Слово `use`:** Введение путей в область видимости для краткости. Переименование с помощью `as`. Использование `self` в пути `use`. Глоб-импорт (`*`).
    *   **7.2.8. Разделение Модулей на Файлы:**
        *   `mod my_module;` в `lib.rs` или `main.rs` ищет `src/my_module.rs` или `src/my_module/mod.rs`.
        *   Иерархия файлов и директорий, соответствующая иерархии модулей.

*   **7.3. Рабочие Области (Workspaces)**
    *   **7.3.1. Цель:** Управление несколькими взаимосвязанными пакетами в одном проекте.
    *   **7.3.2. Структура:** Корневой `Cargo.toml` с секцией `[workspace]`. Общий `Cargo.lock` и `target` директория.
    *   **7.3.3. Команды `cargo` в Workspace.**

*   **7.4. Публикация Крейта на `crates.io`**
    *   **7.4.1. Подготовка:** Документация, лицензия, метаданные в `Cargo.toml`.
    *   **7.4.2. `cargo login`**.
    *   **7.4.3. `cargo publish`**. Управление версиями.

**Раздел 8: Тестирование**

*   **8.1. Основы Тестирования**
    *   **8.1.1. Философия Тестирования в Rust:** Тесты как документация и гарантия корректности.
    *   **8.1.2. Атрибут `#[test]`:** Пометка тестовых функций.
    *   **8.1.3. Макросы `assert!`, `assert_eq!`, `assert_ne!`**.
    *   **8.1.4. Запуск Тестов:** `cargo test`. Флаги (`-- --nocapture`, `-- --ignored`, фильтрация по имени).
    *   **8.1.5. Тестирование Паники:** Атрибут `#[should_panic(expected = "...")`].

*   **8.2. Организация Тестов**
    *   **8.2.1. Модульные Тесты (Unit Tests):**
        *   Размещение в том же файле, что и тестируемый код, внутри подмодуля `#[cfg(test)] mod tests { ... }`.
        *   Доступ к приватным функциям и типам.
    *   **8.2.2. Интеграционные Тесты (Integration Tests):**
        *   Размещение в директории `tests/` на верхнем уровне проекта.
        *   Каждый файл в `tests/` компилируется как отдельный крейт.
        *   Тестируют только публичный API библиотеки.
        *   Необходимость импортировать тестируемый крейт (`use my_crate::...`).
        *   Общий код для интеграционных тестов (`tests/common/mod.rs`).
    *   **8.2.3. Документационные Тесты (Doc Tests):**
        *   Примеры кода в документационных комментариях (`///`), которые `cargo test` выполняет.
        *   Обеспечение актуальности примеров.

*   **8.3. Тестирование Бинарных Крейтов:** Интеграционные тесты для бинарных крейтов (менее прямолинейно, часто включает запуск процесса). Тестирование логики путем вынесения ее в библиотечный крейт.

**Раздел 9: Продвинутые Темы и Идиомы**

*   **9.1. Умные Указатели (Smart Pointers)**
    *   **9.1.1. Концепция:** Структуры, ведущие себя как указатели, но с дополнительной логикой (управление памятью, подсчет ссылок, проверка правил заимствования во время выполнения).
    *   **9.1.2. `Box<T>`:** Простейший умный указатель для выделения данных в куче. Единственный владелец. Используется для рекурсивных типов, передачи владения большими данными.
    *   **9.1.3. `Deref` Трейт:** Позволяет умным указателям вести себя как ссылки (автоматическое разыменование). `Deref coercion`.
    *   **9.1.4. `Drop` Трейт:** Позволяет настроить логику, выполняемую при выходе значения из области видимости (очистка ресурсов).
    *   **9.1.5. `Rc<T>` (Reference Counting):** Подсчет ссылок для разделения владения данными *в однопоточном* окружении. Не позволяет изменять данные. Клонирование `Rc` увеличивает счетчик.
    *   **9.1.6. `Arc<T>` (Atomic Reference Counting):** Атомарный (потокобезопасный) подсчет ссылок для разделения владения данными *в многопоточном* окружении.
    *   **9.1.7. Паттерн Внутренней Изменяемости (Interior Mutability):** Возможность изменять данные даже через неизменяемую ссылку (`&T`). Нарушает обычные правила заимствования, но обеспечивает безопасность через проверки во время выполнения.
        *   **`RefCell<T>`:** Применяет правила заимствования (один `&mut` или много `&`) во время выполнения для `Rc`. Паникует при нарушении. Только для однопоточного окружения. Методы `borrow()`, `borrow_mut()`.
        *   **`Cell<T>`:** Позволяет копировать или заменять значение целиком через `&self`. Работает только с типами, реализующими `Copy`. Нет заимствования, нет паники. Только для однопоточного.
        *   **`Mutex<T>`:** Взаимное исключение (мьютекс) для обеспечения эксклюзивного доступа к данным в многопоточном окружении. Блокировка (`lock()`). Риск взаимоблокировок (deadlocks).
        *   **`RwLock<T>`:** Блокировка чтения-записи. Позволяет иметь либо несколько "читателей", либо одного "писателя" в многопоточном окружении.
    *   **9.1.8. Циклические Ссылки:** Проблемы с `Rc<T>` и `RefCell<T>`. Использование `Weak<T>` для разрыва циклов.

*   **9.2. Итераторы и Замыкания (Closures)**
    *   **9.2.1. Трейт `Iterator`:** Метод `next()`, возвращающий `Option<Item>`. Ленивость итераторов.
    *   **9.2.2. Потребляющие Адаптеры:** `sum()`, `collect()`, etc.
    *   **9.2.3. Адаптеры Итераторов (Iterator Adapters):** `map()`, `filter()`, `zip()`, `take()`, `skip()`, `enumerate()`, etc. Создают новые итераторы. Цепочки вызовов.
    *   **9.2.4. Замыкания (Closures):** Анонимные функции, способные захватывать переменные из окружающей области видимости.
        *   Синтаксис: `|param1, param2| { body }`. Вывод типов параметров и возвращаемого значения.
        *   Захват Окружения: По ссылке (`&`), по изменяемой ссылке (`&mut`), по значению (`move`). Компилятор выводит наименее ограничивающий вариант.
        *   Трейты Замыканий (`Fn`, `FnMut`, `FnOnce`): Как замыкания реализуют эти трейты в зависимости от способа захвата окружения. Использование трейт-баундов с замыканиями.

*   **9.3. Макросы (Macros)**
    *   **9.3.1. Метапрограммирование:** Код, который пишет код.
    *   **9.3.2. Декларативные Макросы (`macro_rules!`):** Сопоставление с образцом и генерация кода. "Гигиена" макросов. Примеры (`vec!`, `println!`). Рекурсивные макросы.
    *   **9.3.3. Процедурные Макросы (Procedural Macros):** Более мощный вид макросов, работающих с потоком токенов во время компиляции. Определяются в отдельных крейтах типа `proc-macro`.
        *   Кастомные `#[derive]` макросы: `#[derive(MyTrait)]`.
        *   Атрибутоподобные макросы: `#[my_attribute]`.
        *   Функциоподобные макросы: `my_macro!(...)`.
        *   Использование библиотек `syn` и `quote` для парсинга и генерации кода.

*   **9.4. Небезопасный Rust (`unsafe`)**
    *   **9.4.1. Пять Способностей `unsafe`:** Разыменование сырых указателей, вызов `unsafe` функций/методов (включая FFI), доступ/изменение `static mut` переменных, реализация `unsafe` трейтов, доступ к полям `union`.
    *   **9.4.2. Сырые Указатели (`*const T`, `*mut T`):** Отличия от ссылок (могут быть null, не гарантируют валидность, не реализуют автоматический `Drop`, игнорируют правила заимствования).
    *   **9.4.3. Причины Использования `unsafe`:** Взаимодействие с другим кодом (FFI), оптимизация производительности, реализация низкоуровневых абстракций.
    *   **9.4.4. Инкапсуляция `unsafe`:** Создание безопасных абстракций поверх небезопасного кода. Ответственность программиста.

*   **9.5. Интерфейс Внешних Функций (Foreign Function Interface - FFI)**
    *   **9.5.1. Вызов Функций C из Rust:** `extern "C" { ... }`, `#[link(...)]`, передача данных (примитивы, указатели). `unsafe`. `#[no_mangle]`.
    *   **9.5.2. Вызов Функций Rust из C:** Создание статической/динамической библиотеки Rust. `#[no_mangle]`, `extern "C" fn`. Создание C-совместимого API. Инструменты (`cbindgen`).
    *   **9.5.3. Безопасность и Управление Памятью при FFI.**

*   **9.6. Продвинутые Типы**
    *   **9.6.1. `newtype` Паттерн:** Обертывание существующего типа в кортежную структуру с одним полем для повышения типобезопасности и возможности реализации внешних трейтов.
    *   **9.6.2. Псевдонимы Типов (`type`):** Создание синонимов для существующих типов. `type Kilometers = i32;`.
    *   **9.6.3. Тип "Никогда" (`!`):** Тип функций, которые никогда не возвращают управление.
    *   **9.6.4. Динамически Размещаемые Типы (Dynamically Sized Types - DSTs) и Трейт `Sized`:** Типы, размер которых неизвестен во время компиляции (`str`, `[T]`, `dyn Trait`). Работа с ними через указатели (`&`, `Box`, etc.).

**Раздел 10: Параллелизм и Асинхронность**

*   **10.1. Параллелизм с Потоками (`std::thread`)**
    *   **10.1.1. Создание Потоков:** `thread::spawn()`. Замыкания `move`.
    *   **10.1.2. Ожидание Завершения:** `JoinHandle` и метод `join()`.
    *   **10.1.3. Каналы (`std::sync::mpsc`) для Передачи Сообщений:** Multiple Producer, Single Consumer. `channel()`, `send()`, `recv()`. Безопасная передача владения между потоками.
    *   **10.1.4. Разделяемое Состояние (`Mutex`, `Arc`)**:
        *   Использование `Arc<Mutex<T>>` для безопасного доступа к общим изменяемым данным из нескольких потоков.
        *   Потенциальные проблемы: взаимоблокировки (deadlocks).
    *   **10.1.5. Трейты `Send` и `Sync`:** Маркерные трейты, обеспечивающие потокобезопасность. `Send`: тип можно безопасно передать (переместить владение) в другой поток. `Sync`: к типу можно безопасно обращаться по ссылке (`&T`) из нескольких потоков одновременно (`T` is `Sync` if `&T` is `Send`). Автоматическая реализация для многих типов.

*   **10.2. Асинхронное Программирование (`async`/`.await`)**
    *   **10.2.1. Проблема Блокирующих Операций:** Неэффективность потоков при ожидании ввода-вывода.
    *   **10.2.2. Модель `async`/`.await`:** Кооперативная многозадачность без явного управления потоками.
    *   **10.2.3. Ключевое Слово `async fn`:** Определяет асинхронную функцию, возвращающую `Future`.
    *   **10.2.4. Трейт `Future`:** Представляет значение, которое может быть доступно в будущем. Метод `poll`.
    *   **10.2.5. Ключевое Слово `.await`:** Приостанавливает выполнение `async fn` до тех пор, пока `Future` не будет готов, не блокируя при этом поток.
    *   **10.2.6. Асинхронные Среды Выполнения (Runtimes):** `Tokio`, `async-std`. Необходимы для запуска `Future` (опрос, управление задачами, реакторы ввода-вывода).
    *   **10.2.7. Экосистема:** Асинхронные версии стандартных примитивов (мьютексы, каналы), асинхронные трейты, библиотеки для работы с сетью, файлами и т.д.
    *   **10.2.8. `Pin<P>`:** Обеспечение того, что значение не будет перемещено в памяти (важно для некоторых `Future`).
    *   **10.2.9. Потоки (`Stream`):** Асинхронный аналог итераторов.

**Раздел 11: Экосистема и Инструменты**

*   **11.1. Основные Инструменты (Повторение и Углубление)**
    *   **11.1.1. `cargo`:** Управление зависимостями (версии, features), профили сборки, пользовательские подкоманды, скрипты сборки (`build.rs`).
    *   **11.1.2. `rustfmt`:** Автоматическое форматирование кода. Настройка (`rustfmt.toml`).
    *   **11.1.3. `clippy`:** Продвинутый линтер для поиска ошибок, анти-паттернов, неидиоматичного кода. Настройка (`clippy.toml`).
    *   **11.1.4. `rust-analyzer`:** Language Server Protocol (LSP) сервер для интеграции с IDE.
    *   **11.1.5. `rustdoc`:** Генерация документации. Markdown в док-комментариях.

*   **11.2. Отладка и Профилирование**
    *   **11.2.1. Отладчики:** Интеграция с GDB/LLDB. Расширения для VS Code/IntelliJ.
    *   **11.2.2. Профилирование:** `perf` (Linux), Instruments (macOS), `cargo flamegraph`, `cargo profiler`.
    *   **11.2.3. Бенчмаркинг:** Крейт `criterion`. `cargo bench`.

*   **11.3. Популярные Крейты и Области Применения**
    *   **11.3.1. Веб-разработка (Backend):** `actix-web`, `rocket`, `axum`, `warp`. Шаблонизаторы (`tera`, `askama`). ORM (`diesel`, `sqlx`).
    *   **11.3.2. Веб-разработка (Frontend - WebAssembly):** `wasm-bindgen`, `wasm-pack`. Фреймворки (`yew`, `leptos`, `dioxus`).
    *   **11.3.3. Системное Программирование:** Взаимодействие с ОС, встраиваемые системы (`embedded rust`).
    *   **11.3.4. Сетевое Программирование:** `tokio`, `mio`.
    *   **11.3.5. Инструменты Командной Строки (CLI):** `clap`, `structopt`, `indicatif`, `termion`/`crossterm`.
    *   **11.3.6. Сериализация/Десериализация:** `serde`. Форматы (`serde_json`, `serde_yaml`, `bincode`, `prost`/`tonic` для gRPC).
    *   **11.3.7. Логирование:** `log`, `env_logger`, `tracing`.
    *   **11.3.8. Научные вычисления / Данные:** `ndarray`, `polars`.
    *   **11.3.9. Разработка Игр:** `bevy`, `fyrox`.

**Раздел 12: Паттерны Проектирования и Лучшие Практики**

*   **12.1. Идиоматичный Rust:** Написание кода в стиле, принятом в сообществе (использование `Option`/`Result`, итераторов, трейтов, избегание `unsafe` и т.д.).
*   **12.2. Паттерны Проектирования в Rust:**
    *   Строитель (Builder Pattern).
    *   Newtype Pattern (уже упоминался).
    *   Использование трейтов для стратегий/абстракций.
    *   RAII (Resource Acquisition Is Initialization) через `Drop`.
    *   Обработка ошибок (пропагация `?`, кастомные типы ошибок).
    *   Типовые состояния (Type State Pattern).
*   **12.3. Управление Зависимостями:** Семантическое версионирование, использование `features`, `dev-dependencies`, `build-dependencies`.
*   **12.4. Организация Больших Проектов:** Модули, рабочие области, вынесение логики в библиотеки.
*   **12.5. Работа с `unsafe`:** Минимизация, инкапсуляция, документирование инвариантов.

---

**Рекомендации по Процессу Изучения:**

1.  **Практика:** Пишите код постоянно. Решайте задачи на платформах типа Exercism, LeetCode, Codewars, Advent of Code на Rust.
2.  **Чтение "The Book":** Официальная книга ("The Rust Programming Language") - отличная отправная точка. Прочитайте её внимательно.
3.  **Rustlings:** Пройдите интерактивный курс `rustlings` (`cargo install rustlings && rustlings watch`).
4.  **Документация:** Научитесь эффективно пользоваться `rustdoc` (`cargo doc --open`), документацией стандартной библиотеки и популярных крейтов.
5.  **Эксперименты:** Не бойтесь пробовать разные подходы, смотреть, как компилятор реагирует на ошибки.
6.  **Чтение Чужого Кода:** Изучайте исходный код популярных крейтов на GitHub.
7.  **Участие в Сообществе:** Задавайте вопросы на форумах (users.rust-lang.org), в Discord/Zulip, читайте блоги.
8.  **Небольшие Проекты:** Постепенно переходите к созданию своих небольших проектов для закрепления знаний в конкретных областях (CLI, веб-сервер, простая игра и т.д.).

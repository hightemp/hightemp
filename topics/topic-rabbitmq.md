**I. Основы и концепции**

1. **Введение в обмен сообщениями и AMQP:**
    *   **1.1. Понятие асинхронного обмена сообщениями:**
        *   1.1.1. Различие между синхронным и асинхронным взаимодействием.
        *   1.1.2. Преимущества асинхронной модели: слабая связанность, масштабируемость, отказоустойчивость, отзывчивость.
        *   1.1.3. Сценарии использования асинхронного обмена сообщениями: фоновые задачи, распределенные системы, микросервисы.
    *   **1.2. Протокол AMQP (Advanced Message Queuing Protocol):**
        *   1.2.1. История и назначение AMQP.
        *   1.2.2. Версии AMQP: 0-9-1, 1.0. Сравнение и особенности.
        *   1.2.3. Основные компоненты AMQP: модель обмена сообщениями (publish/subscribe), модель очереди (queue), каналы (channels), соединения (connections).
    *   **1.3. Обзор брокеров сообщений:**
        *   1.3.1. Роль брокера сообщений в системе.
        *   1.3.2. Сравнение популярных брокеров: RabbitMQ, Kafka, ActiveMQ, ZeroMQ.
        *   1.3.3. Критерии выбора брокера сообщений.

2. **Установка и настройка RabbitMQ:**
    *   **2.1. Установка RabbitMQ:**
        *   2.1.1. Установка на различные операционные системы (Linux, Windows, macOS).
        *   2.1.2. Установка из пакетов, из исходного кода, с помощью Docker.
        *   2.1.3. Настройка переменных окружения.
    *   **2.2. Первоначальная настройка:**
        *   2.2.1. Запуск и остановка сервера RabbitMQ.
        *   2.2.2. Управление пользователями и правами доступа (vhost, permissions).
        *   2.2.3. Использование интерфейса управления RabbitMQ Management Plugin.
        *   2.2.4. Мониторинг состояния сервера через Management Plugin.
    *   **2.3. Базовая конфигурация:**
        *   2.3.1. Конфигурационные файлы: rabbitmq.conf, advanced.config.
        *   2.3.2. Настройка сетевых параметров (порты, интерфейсы).
        *   2.3.3. Включение и настройка плагинов.

**II. Основные элементы RabbitMQ**

3. **Обменники (Exchanges):**
    *   **3.1. Роль обменников в маршрутизации сообщений:**
        *   3.1.1. Прием сообщений от производителей (publishers).
        *   3.1.2. Маршрутизация сообщений в очереди на основе правил.
    *   **3.2. Типы обменников:**
        *   3.2.1. **Direct exchange:** маршрутизация по точному совпадению ключа маршрутизации (routing key).
        *   3.2.2. **Fanout exchange:** широковещательная рассылка всем связанным очередям.
        *   3.2.3. **Topic exchange:** маршрутизация по шаблону ключа маршрутизации с использованием подстановочных знаков (* и #).
        *   3.2.4. **Headers exchange:** маршрутизация на основе заголовков сообщения.
        *   3.2.5. **Consistent Hashing Exchange:** распределение сообщений по очередям с помощью алгоритма консистентного хеширования для ключа.
        *   3.2.6. **Exchange-to-Exchange Bindings:** связывание exchange'ей между собой для каскадной маршрутизации.
    *   **3.3. Атрибуты обменников:**
        *   3.3.1. **Durable:** сохранение обменника при перезапуске сервера.
        *   3.3.2. **Auto-delete:** автоматическое удаление обменника, когда нет связанных очередей.
        *   3.3.3. **Internal:** обменник не предназначен для публикации сообщений напрямую.
        *   3.3.4. **Alternate Exchange:** перенаправление немаршрутизированных сообщений.
    *   **3.4. Объявление и удаление обменников:**
        *   3.4.1. Программное объявление обменников через клиентские библиотеки.
        *   3.4.2. Объявление обменников через Management Plugin.

4. **Очереди (Queues):**
    *   **4.1. Назначение очередей:**
        *   4.1.1. Хранение сообщений до момента их обработки потребителями (consumers).
        *   4.1.2. Гарантия доставки сообщений.
    *   **4.2. Свойства очередей:**
        *   4.2.1. **Durable:** сохранение очереди при перезапуске сервера.
        *   4.2.2. **Exclusive:** очередь доступна только для одного соединения.
        *   4.2.3. **Auto-delete:** автоматическое удаление очереди, когда нет активных потребителей.
    *   **4.3. Дополнительные параметры очередей:**
        *   4.3.1. **Message TTL:** время жизни сообщения в очереди.
        *   4.3.2. **Queue Length Limit:** ограничение максимальной длины очереди.
        *   4.3.3. **Dead Letter Exchange:** перенаправление сообщений, которые не могут быть обработаны.
        *   4.3.4. **Dead Letter Routing Key:** ключ маршрутизации для сообщений, перенаправленных в Dead Letter Exchange.
        *   4.3.5. **Lazy Queues:** хранение сообщений на диске для экономии оперативной памяти.
        *   4.3.6. **Quorum Queues:** реплицируемые очереди для повышения надежности.
        *   4.3.7. **Stream Queues:** очереди, предназначенные для хранения и обработки потоков данных.
    *   **4.4. Объявление и удаление очередей:**
        *   4.4.1. Программное объявление очередей через клиентские библиотеки.
        *   4.4.2. Объявление очередей через Management Plugin.

5. **Привязки (Bindings):**
    *   **5.1. Роль привязок:**
        *   5.1.1. Определение правил маршрутизации сообщений от обменников к очередям.
        *   5.1.2. Связывание обменника и очереди с указанием ключа маршрутизации (для direct и topic) или заголовков (для headers).
    *   **5.2. Создание и удаление привязок:**
        *   5.2.1. Программное создание привязок через клиентские библиотеки.
        *   5.2.2. Создание привязок через Management Plugin.

**III. Взаимодействие с RabbitMQ**

6. **Производители (Publishers):**
    *   **6.1. Публикация сообщений:**
        *   6.1.1. Создание соединения и канала.
        *   6.1.2. Объявление обменника.
        *   6.1.3. Отправка сообщений в обменник с указанием ключа маршрутизации.
        *   6.1.4. Обработка возвращаемых сообщений (mandatory флаг).
    *   **6.2. Свойства сообщений:**
        *   6.2.1. **Headers:** произвольные метаданные сообщения.
        *   6.2.2. **Delivery mode:** persistent (сохранение на диск) или transient (не сохраняется).
        *   6.2.3. **Priority:** приоритет сообщения.
        *   6.2.4. **Expiration:** время жизни сообщения.
        *   6.2.5. **Content type:** тип содержимого сообщения (например, application/json).
        *   6.2.6. **Content encoding:** кодировка содержимого сообщения (например, gzip).
    *   **6.3. Publisher Confirms:**
        *   6.3.1. Механизм подтверждения доставки сообщений брокеру.
        *   6.3.2. Асинхронная и синхронная обработка подтверждений.
        *   6.3.3. Повышение надежности доставки сообщений.
    *   **6.4. Transactions:**
        *   6.4.1. Использование транзакций для обеспечения атомарной публикации сообщений.
        *   6.4.2. Влияние транзакций на производительность.

7. **Потребители (Consumers):**
    *   **7.1. Получение сообщений:**
        *   7.1.1. Создание соединения и канала.
        *   7.1.2. Объявление очереди.
        *   7.1.3. Подписка на очередь (basic.consume).
        *   7.1.4. Получение сообщений по запросу (basic.get).
    *   **7.2. Подтверждение обработки сообщений (Acknowledgements):**
        *   7.2.1. Автоматическое подтверждение (autoAck).
        *   7.2.2. Ручное подтверждение (basic.ack, basic.nack, basic.reject).
        *   7.2.3. Стратегии обработки ошибок: повторная обработка, отбрасывание, перенаправление в Dead Letter Exchange.
    *   **7.3. Prefetch count (QoS):**
        *   7.3.1. Ограничение количества неподтвержденных сообщений, которые может получить потребитель.
        *   7.3.2. Влияние на производительность и распределение нагрузки.
    *   **7.4. Consumer cancellation:**
        *   7.4.1. Отмена подписки на очередь.
        *   7.4.2. Обработка уведомлений об отмене подписки.
    *   **7.5. Consumer Priority:**
        *   7.5.1. Указание приоритета для потребителей на одной очереди.
        *   7.5.2. Распределение сообщений в первую очередь потребителям с более высоким приоритетом.
    *   **7.6. Exclusive Consumers:**
        *   7.6.1. Ограничение количества потребителей, которые могут одновременно получать сообщения из очереди.

**IV. Расширенные возможности и надежность**

8. **Кластеризация (Clustering):**
    *   **8.1. Преимущества кластеризации:**
        *   8.1.1. Высокая доступность (High Availability).
        *   8.1.2. Масштабируемость.
        *   8.1.3. Распределение нагрузки.
    *   **8.2. Настройка кластера:**
        *   8.2.1. Объединение нескольких узлов RabbitMQ в кластер.
        *   8.2.2. Использование DNS или статических IP-адресов для обнаружения узлов.
        *   8.2.3. Настройка синхронизации данных между узлами.
    *   **8.3. Поведение очередей в кластере:**
        *   8.3.1. Размещение очередей на разных узлах.
        *   8.3.2. Mirrored Queues (устаревший механизм): репликация очередей на несколько узлов для повышения надежности.
        *   8.3.3. Федерация (Federation): обмен сообщениями между кластерами.
        *   8.3.4. Shovels: перенос сообщений между серверами.
    *   **8.4. Отказоустойчивость:**
        *   8.4.1. Поведение кластера при отказе одного или нескольких узлов.
        *   8.4.2. Автоматическое восстановление после сбоя.

9. **Федерация (Federation):**
    *   **9.1. Назначение федерации:**
        *   9.1.1. Обмен сообщениями между разными кластерами RabbitMQ или отдельными серверами.
        *   9.1.2. Создание распределенных систем обмена сообщениями.
    *   **9.2. Настройка федерации:**
        *   9.2.1. Federation Upstreams: настройка подключения к удаленному серверу.
        *   9.2.2. Federation Policies: определение правил обмена сообщениями.
    *   **9.3. Federation Exchanges and Queues:**
        *   9.3.1. Особенности работы федеративных обменников и очередей.
    *   **9.4. Преимущества и ограничения федерации.**

10. **Shovels:**
    *   **10.1. Назначение Shovels:**
        *   10.1.1. Надежный перенос сообщений между брокерами или кластерами.
        *   10.1.2. Миграция сообщений.
    *   **10.2. Настройка Shovels:**
        *   10.2.1. Static Shovels: настройка через конфигурационные файлы.
        *   10.2.2. Dynamic Shovels: настройка через Management Plugin.
    *   **10.3. Преимущества и ограничения Shovels.**

11. **Политики (Policies):**
    *   **11.1. Назначение политик:**
        *   11.1.1. Централизованное управление настройками очередей, обменников и федерации.
        *   11.1.2. Применение настроек к группе объектов на основе шаблона имени.
    *   **11.2. Настройка политик:**
        *   11.2.1. Определение политик через Management Plugin или CLI.
        *   11.2.2. Приоритет политик.
    *   **11.3. Примеры использования политик:**
        *   11.3.1. Настройка Dead Letter Exchanges для всех очередей.
        *   11.3.2. Включение Mirrored Queues для определенного набора очередей.

12. **Пользователи и права доступа (vhosts, permissions):**
    *   **12.1 Виртуальные хосты (vhosts):**
        *   12.1.1. Изоляция ресурсов и конфигурации в рамках одного сервера RabbitMQ.
        *   12.1.2. Создание и управление vhosts.
    *   **12.2. Управление пользователями:**
        *   12.2.1. Создание, изменение и удаление пользователей.
        *   12.2.2. Назначение тегов пользователям (administrator, monitoring, policymaker, management).
    *   **12.3. Настройка прав доступа:**
        *   12.3.1. Предоставление разрешений на уровне vhost: configure, write, read.
        *   12.3.2. Регулярные выражения для настройки доступа к группам ресурсов.
    *   **12.4. Аутентификация и авторизация:**
        *   12.4.1. Встроенные механизмы аутентификации (username/password).
        *   12.4.2. Использование внешних систем аутентификации (LDAP, OAuth 2.0).

**V. Мониторинг и отладка**

13. **Мониторинг RabbitMQ:**
    *   **13.1. RabbitMQ Management Plugin:**
        *   13.1.1. Веб-интерфейс для мониторинга состояния сервера, очередей, обменников, соединений и каналов.
        *   13.1.2. Просмотр статистики в реальном времени.
        *   13.1.3. HTTP API для программного доступа к метрикам.
    *   **13.2. Инструменты командной строки:**
        *   13.2.1. `rabbitmqctl`: управление сервером, пользователями, vhosts, политиками.
        *   13.2.2. `rabbitmq-diagnostics`: проверка состояния сервера, сбор диагностической информации.
    *   **13.3. Интеграция с системами мониторинга:**
        *   13.3.1. Prometheus: сбор метрик через плагин `rabbitmq_prometheus`.
        *   13.3.2. Grafana: визуализация метрик.
        *   13.3.3. Datadog, Nagios, Zabbix и другие.
    *   **13.4. Логирование:**
        *   13.4.1. Настройка уровней логирования.
        *   13.4.2. Анализ логов RabbitMQ.
    *   **13.5. Firehose:**
        *   13.5.1. Отладка сообщений в режиме реального времени.
        *   13.5.2. Перехват сообщений, публикуемых и получаемых.

14. **Отладка приложений RabbitMQ:**
    *   **14.1. Использование Firehose для трассировки сообщений.**
    *   **14.2. Анализ логов приложений и RabbitMQ.**
    *   **14.3. Использование инструментов отладки, предоставляемых клиентскими библиотеками.**
    *   **14.4. Изолирование проблем: локализация проблем, связанных с производительностью или некорректной работой.**

**VI. Клиентские библиотеки и интеграция**

15. **Клиентские библиотеки RabbitMQ:**
    *   **15.1. Обзор поддерживаемых языков программирования:**
        *   15.1.1. Java, .NET, Python, Ruby, JavaScript, PHP, Go и другие.
    *   **15.2. Официальные клиенты:**
        *   15.2.1. Предоставляются и поддерживаются командой RabbitMQ.
        *   15.2.2. Примеры: `amqp-client` (Java), `pika` (Python), `RabbitMQ.Client` (.NET).
    *   **15.3. Сторонние клиенты:**
        *   15.3.1. Разрабатываются сообществом.
        *   15.3.2. Примеры: `Bunny` (Ruby), `amqplib` (Node.js).
    *   **15.4. Выбор клиентской библиотеки:**
        *   15.4.1. Критерии выбора: поддерживаемый функционал, производительность, надежность, простота использования, наличие документации и поддержки.
    *   **15.5. Фреймворки и интеграции:**
        *   15.5.1. Spring AMQP: интеграция с фреймворком Spring.
        *   15.5.2. MassTransit: библиотека для построения распределенных приложений на .NET.
        *   15.5.3. NServiceBus: платформа для построения распределенных систем на .NET.
        *   15.5.4. Kombu: библиотека обмена сообщениями для Python.

16. **Интеграция с другими системами:**
    *   **16.1. Использование плагинов:**
        *   16.1.1. Расширение функциональности RabbitMQ.
        *   16.1.2. Примеры: `rabbitmq_management`, `rabbitmq_federation`, `rabbitmq_shovel`, `rabbitmq_mqtt`, `rabbitmq_stomp`.
    *   **16.2. REST API:**
        *   16.2.1. Взаимодействие с RabbitMQ через HTTP.
        *   16.2.2. Использование для интеграции с системами, не поддерживающими AMQP.
    *   **16.3. MQTT:**
        *   16.3.1. Поддержка протокола MQTT для обмена сообщениями с IoT-устройствами.
    *   **16.4. STOMP:**
        *   16.4.1. Поддержка протокола STOMP для обмена сообщениями через текстовые протоколы.
    *   **16.5. WebSockets:**
        *   16.5.1. Обмен сообщениями с веб-приложениями через плагин `rabbitmq_web_stomp`.

**VII. Best Practices и продвинутые сценарии**

17. **Best Practices:**
    *   **17.1. Разработка:**
        *   17.1.1. Использование Publisher Confirms для обеспечения надежности доставки.
        *   17.1.2. Обработка ошибок и повторная обработка сообщений.
        *   17.1.3. Использование Dead Letter Exchanges для обработки недоставленных сообщений.
        *   17.1.4. Настройка TTL для сообщений и очередей.
        *   17.1.5. Использование Lazy Queues для экономии оперативной памяти.
    *   **17.2. Производительность:**
        *   17.2.1. Оптимальная настройка Prefetch count.
        *   17.2.2. Использование нескольких соединений и каналов.
        *   17.2.3. Выбор подходящего типа обменника.
        *   17.2.4. Минимизация размера сообщений.
        *   17.2.5. Использование асинхронных операций.
        *   17.2.6. Настройка TCP keepalive.
    *   **17.3. Безопасность:**
        *   17.3.1. Использование TLS для шифрования трафика.
        *   17.3.2. Настройка пользователей и прав доступа.
        *   17.3.3. Регулярное обновление RabbitMQ до последней версии.
    *   **17.4. Мониторинг:**
        *   17.4.1. Мониторинг ключевых метрик: длина очереди, скорость обработки сообщений, количество соединений и каналов.
        *   17.4.2. Настройка оповещений при возникновении проблем.

18. **Продвинутые сценарии использования:**
    *   **18.1. RPC (Remote Procedure Call):**
        *   18.1.1. Реализация синхронного взаимодействия с использованием RabbitMQ.
        *   18.1.2. Использование временных очередей для ответов.
    *   **18.2. Распределенная трассировка:**
        *   18.2.1. Отслеживание прохождения сообщений через распределенную систему.
        *   18.2.2. Использование заголовков сообщений для передачи информации о трассировке.
    *   **18.3. Event Sourcing:**
        *   18.3.1. Хранение истории изменений состояния системы в виде последовательности событий.
        *   18.3.2. Использование RabbitMQ для передачи событий.
    *   **18.4. Микросервисная архитектура:**
        *   18.4.1. Использование RabbitMQ для асинхронного взаимодействия между микросервисами.
        *   18.4.2. Реализация шаблонов Saga, CQRS.
    *   **18.5. Обработка потоков данных:**
        *   18.5.1. Использование Stream Queues для обработки больших объемов данных в реальном времени.

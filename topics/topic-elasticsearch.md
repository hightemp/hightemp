**I. Введение и основы:**

*   **1. Что такое Elasticsearch?**
    *   1.1. Понятие поисковой системы.
    *   1.2. Отличие Elasticsearch от реляционных баз данных (SQL).
    *   1.3. Основные концепции:
        *   1.3.1. Документ (Document).
        *   1.3.2. Индекс (Index).
        *   1.3.3. Тип (Type) - **Устаревший концепт, рассмотреть его исторический контекст и альтернативы.**
        *   1.3.4. Поле (Field).
        *   1.3.5. Отображение (Mapping).
        *   1.3.6. Шард (Shard) и Реплика (Replica).
        *   1.3.7. Узел (Node).
        *   1.3.8. Кластер (Cluster).
    *   1.4. Архитектура Elasticsearch.
        *   1.4.1. Распределенная природа.
        *   1.4.2. Роли узлов: Master, Data, Ingest, Coordinating, Machine Learning.
        *   1.4.3. Принцип работы репликации и шардирования.
    *   1.5. Области применения Elasticsearch.
        *   1.5.1. Полнотекстовый поиск.
        *   1.5.2. Анализ логов.
        *   1.5.3. Аналитика в реальном времени.
        *   1.5.4. Мониторинг приложений.
        *   1.5.5. Бизнес-аналитика.

*   **2. Установка и настройка:**
    *   2.1. Установка Elasticsearch:
        *   2.1.1. На Linux (разные дистрибутивы).
        *   2.1.2. На macOS.
        *   2.1.3. На Windows.
        *   2.1.4. С использованием Docker.
        *   2.1.5. Облачные сервисы (Elastic Cloud, AWS Elasticsearch Service, etc.)
    *   2.2. Основные файлы конфигурации:
        *   2.2.1. `elasticsearch.yml`.
            *   2.2.1.1. Настройка путей.
            *   2.2.1.2. Настройка сети.
            *   2.2.1.3. Настройка кластера.
            *   2.2.1.4. Настройка памяти.
            *   2.2.1.5. Настройка безопасности.
        *   2.2.2. `jvm.options`.
    *   2.3. Запуск и остановка Elasticsearch.
    *   2.4. Проверка работоспособности кластера (Cluster Health API).

**II. Индексирование данных:**

*   **3. Индексирование документов:**
    *   3.1. Index API.
        *   3.1.1. Создание и удаление индексов.
        *   3.1.2. Добавление одного документа.
        *   3.1.3. Обновление документа.
        *   3.1.4. Удаление документа.
    *   3.2. Bulk API.
        *   3.2.1. Массовое добавление документов.
        *   3.2.2. Массовое обновление документов.
        *   3.2.3. Массовое удаление документов.
        *   3.2.4. Оптимизация производительности Bulk API.
    *   3.3. Понятие ID документа.
        *   3.3.1. Автоматическая генерация ID.
        *   3.3.2. Указание собственного ID.
    *   3.4. Динамическое отображение (Dynamic Mapping).
        *   3.4.1. Автоматическое определение типов полей.
        *   3.4.2. Ограничения динамического отображения.
    *   3.5. Явное отображение (Explicit Mapping).
        *   3.5.1. Типы данных:
            *   3.5.1.1. Текстовые типы (text, keyword).
            *   3.5.1.2. Числовые типы (long, integer, short, byte, double, float, half_float, scaled_float).
            *   3.5.1.3. Дата (date).
            *   3.5.1.4. Логический тип (boolean).
            *   3.5.1.5. Бинарный тип (binary).
            *   3.5.1.6. Диапазоны (range types).
            *   3.5.1.7. Геоданные (geo_point, geo_shape).
            *   3.5.1.8. Специальные типы (IP, completion, token_count, mapper-murmur3, etc.).
        *   3.5.2. Параметры полей:
            *   3.5.2.1. `analyzer`.
            *   3.5.2.2. `index`.
            *   3.5.2.3. `store`.
            *   3.5.2.4. `doc_values`.
            *   3.5.2.5. `norms`.
        *   3.5.3. Мультиполя (Multi-fields).
    *   3.6. Ingest Pipelines (Пайплайны обработки):
        *   3.6.1. Предварительная обработка данных перед индексированием.
        *   3.6.2. Процессоры (Processors):
            *   3.6.2.1. `set`.
            *   3.6.2.2. `remove`.
            *   3.6.2.3. `rename`.
            *   3.6.2.4. `convert`.
            *   3.6.2.5. `grok`.
            *   3.6.2.6. `date`.
            *   3.6.2.7. `geoip`.
            *   3.6.2.8. и другие.
        *   3.6.3. Условные операции в пайплайнах.
        *   3.6.4. Обработка ошибок в пайплайнах.
    *   3.7. Индексные шаблоны (Index Templates).
        *   3.7.1. Автоматическое применение настроек и отображений к новым индексам.
        *   3.7.2. Управление шаблонами.

**III. Поиск данных:**

*   **4. Основы поиска:**
    *   4.1. Search API.
    *   4.2. URI Search.
    *   4.3. Request Body Search (DSL).
    *   4.4. Понятие релевантности (Relevance).
    *   4.5. Модель подсчета релевантности TF/IDF, BM25.
    *   4.6. Параметры запроса:
        *   4.6.1. `from` и `size`.
        *   4.6.2. `_source`.
        *   4.6.3. `sort`.
*   **5. Query DSL:**
    *   5.1. Типы запросов:
        *   5.1.1. Match Query.
        *   5.1.2. Match Phrase Query.
        *   5.1.3. Multi Match Query.
        *   5.1.4. Term Query.
        *   5.1.5. Terms Query.
        *   5.1.6. Range Query.
        *   5.1.7. Exists Query.
        *   5.1.8. Prefix Query.
        *   5.1.9. Wildcard Query.
        *   5.1.10. Regexp Query.
        *   5.1.11. Fuzzy Query.
        *   5.1.12. Bool Query (must, should, must_not, filter).
        *   5.1.13. Boosting Query.
        *   5.1.14. Constant Score Query.
        *   5.1.15. Dis Max Query.
        *   5.1.16. Function Score Query.
        *   5.1.17. Nested Query.
        *   5.1.18. Has Child Query.
        *   5.1.19. Has Parent Query.
        *   5.1.20. Geo Queries (geo_distance, geo_bounding_box, geo_polygon).
    *   5.2. Контексты запросов (Query Context) и фильтрации (Filter Context).
    *   5.3. Агрегации (Aggregations).
        *   5.3.1. Метрические агрегации (Metric Aggregations):
            *   5.3.1.1. `avg`.
            *   5.3.1.2. `sum`.
            *   5.3.1.3. `min`.
            *   5.3.1.4. `max`.
            *   5.3.1.5. `stats`.
            *   5.3.1.6. `extended_stats`.
            *   5.3.1.7. `percentiles`.
            *   5.3.1.8. `cardinality`.
            *   5.3.1.9. `value_count`.
        *   5.3.2. Bucket агрегации (Bucket Aggregations):
            *   5.3.2.1. `terms`.
            *   5.3.2.2. `histogram`.
            *   5.3.2.3. `date_histogram`.
            *   5.3.2.4. `range`.
            *   5.3.2.5. `date_range`.
            *   5.3.2.6. `geo_distance`.
            *   5.3.2.7. `filters`.
        *   5.3.3. Pipeline агрегации (Pipeline Aggregations):
            *   5.3.3.1. `avg_bucket`.
            *   5.3.3.2. `sum_bucket`.
            *   5.3.3.3. `min_bucket`.
            *   5.3.3.4. `max_bucket`.
            *   5.3.3.5. `stats_bucket`.
            *   5.3.3.6. `extended_stats_bucket`.
            *   5.3.3.7. `percentiles_bucket`.
            *   5.3.3.8. `bucket_selector`.
            *   5.3.3.9. `bucket_sort`.
            *   5.3.3.10. `derivative`.
            *   5.3.3.11. `cumulative_sum`.
            *   5.3.3.12. `moving_avg`.
            *   5.3.3.13. `serial_diff`.
        *   5.3.4. Вложенные агрегации (Nested Aggregations).
        *   5.3.5. Матричные агрегации (Matrix Aggregations).
*   **6. Анализ текста:**
    *   6.1. Понятие анализатора (Analyzer).
    *   6.2. Компоненты анализатора:
        *   6.2.1. Character Filters.
        *   6.2.2. Tokenizer.
        *   6.2.3. Token Filters.
    *   6.3. Встроенные анализаторы:
        *   6.3.1. `standard`.
        *   6.3.2. `simple`.
        *   6.3.3. `whitespace`.
        *   6.3.4. `stop`.
        *   6.3.5. `keyword`.
        *   6.3.6. `pattern`.
        *   6.3.7. `language` analyzers.
        *   6.3.8. `fingerprint`.
    *   6.4. Создание пользовательских анализаторов.
    *   6.5. Analyze API.
    *   6.6. Нормализаторы (Normalizers).
    *   6.7. Синонимы (Synonyms).
    *   6.8. Стемминг (Stemming).
    *   6.9. Лемматизация (Lemmatization).

**IV. Продвинутые темы:**

*   **7. Управление кластером:**
    *   7.1. Cluster API.
        *   7.1.1. Мониторинг состояния кластера.
        *   7.1.2. Управление настройками кластера.
        *   7.1.3. Управление узлами.
        *   7.1.4. Управление задачами (Tasks).
        *   7.1.5. Управление распределением шардов (Shard Allocation).
        *   7.1.6. Принудительное перераспределение шардов.
        *   7.1.7. Отложенное распределение шардов.
    *   7.2. Индексы жизненного цикла (Index Lifecycle Management - ILM).
        *   7.2.1. Автоматизация управления индексами в зависимости от их возраста и размера.
        *   7.2.2. Фазы жизненного цикла (Hot, Warm, Cold, Delete).
        *   7.2.3. Настройка политик ILM.
    *   7.3. Снимки и восстановление (Snapshots and Restore).
        *   7.3.1. Создание резервных копий индексов.
        *   7.3.2. Восстановление индексов из резервных копий.
        *   7.3.3. Управление репозиториями снимков.
    *   7.4. Обновление Elasticsearch (Rolling Upgrades, Full Cluster Restart Upgrades).
*   **8. Безопасность:**
    *   8.1. Встроенные средства безопасности (Security Features)
        *   8.1.1. Аутентификация (Authentication).
            *   8.1.1.1 Встроенные пользователи и роли
            *   8.1.1.2. Интеграция с LDAP, Active Directory, Kerberos, PKI и другие.
        *   8.1.2. Авторизация (Authorization).
            *   8.1.2.1. Ролевая модель доступа (RBAC).
            *   8.1.2.2. Управление доступом на уровне полей и документов.
        *   8.1.3. Шифрование трафика (TLS/SSL).
        *   8.1.4. Аудит (Auditing).
        *   8.1.5. IP Filtering
    *   8.2. Интеграция с сторонними системами безопасности.
*   **9. Производительность:**
    *   9.1. Мониторинг производительности:
        *   9.1.1. Monitoring API.
        *   9.1.2. Использование Kibana для мониторинга.
        *   9.1.3. Использование сторонних инструментов (Prometheus, Grafana).
    *   9.2. Оптимизация производительности индексирования.
    *   9.3. Оптимизация производительности поиска.
        *   9.3.1. Кэширование запросов (Query Cache).
        *   9.3.2. Кэширование файловой системы (Filesystem Cache).
        *   9.3.3. Fielddata и Doc values.
    *   9.4. Профилирование запросов (Profile API).
    *   9.5. Тюнинг JVM
    *   9.6. Тюнинг операционной системы
*   **10. Расширенные возможности:**
    *   10.1. Скрипты (Scripting).
        *   10.1.1. Painless scripting language
        *   10.1.2. Использование скриптов в запросах, агрегациях, обновлениях и ingest pipelines.
        *   10.1.3  Безопасность при использовании скриптов.
    *   10.2. Plugins.
        *   10.2.1. Установка и управление плагинами.
        *   10.2.2. Популярные плагины (analysis-icu, analysis-phonetic, mapper-attachments, etc.).
        *   10.2.3. Разработка собственных плагинов.
    *   10.3. Cross-Cluster Search.
    *   10.4. Cross-Cluster Replication.
    *   10.5. Machine Learning.
        *   10.5.1  Anomaly Detection
        *   10.5.2  Data Frame Analytics
        *   10.5.3  Supervised Learning
    *   10.6. Graph exploration with Graph API (устаревший функционал)
    *   10.7. Elasticsearch SQL.
*   **11. Интеграция с другими инструментами:**
    *   11.1. Kibana.
        *   11.1.1. Визуализация данных.
        *   11.1.2. Создание дашбордов.
        *   11.1.3. Управление индексами.
        *   11.1.4. Dev Tools.
    *   11.2. Logstash.
        *   11.2.1. Сбор и обработка логов.
        *   11.2.2. Фильтры Logstash.
        *   11.2.3. Отправка данных в Elasticsearch.
    *   11.3. Beats.
        *   11.3.1. Filebeat.
        *   11.3.2. Metricbeat.
        *   11.3.3. Packetbeat.
        *   11.3.4. Heartbeat.
        *   11.3.5. Auditbeat.
        *   11.3.6. Functionbeat.
    *   11.4. Интеграция с Hadoop, Spark, Kafka.
    *   11.5. Языковые клиенты (Java, Python, JavaScript, Go, .NET, etc.).
* **12. Лучшие практики:**
    * 12.1 Проектирование индексов и маппингов
    * 12.2  Оптимизация производительности запросов
    * 12.3  Мониторинг и траблшутинг
    * 12.4  Обеспечение безопасности
    * 12.5  Масштабирование кластера
    * 12.6  Управление жизненным циклом индексов
    * 12.7  Резервное копирование и восстановление

**V. Освоение на практике:**

*   **13. Практические задания и проекты:**
    *   13.1. Создание индекса с определенным маппингом.
    *   13.2. Индексирование данных из различных источников (CSV, JSON, базы данных).
    *   13.3. Написание запросов различной сложности с использованием Query DSL.
    *   13.4. Создание агрегаций для анализа данных.
    *   13.5. Настройка Ingest Pipelines для обработки данных перед индексированием.
    *   13.6. Настройка ILM для управления индексами.
    *   13.7. Создание снимков и восстановление данных.
    *   13.8. Настройка безопасности кластера.
    *   13.9. Оптимизация производительности индексирования и поиска.
    *   13.10. Реализация реальных сценариев использования Elasticsearch (поиск по сайту, анализ логов, мониторинг приложений).
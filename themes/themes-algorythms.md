Хорошо, я постараюсь сделать список максимально полным, насколько это вообще возможно. Учитывая, что теория алгоритмов - это обширная и постоянно развивающаяся область, **абсолютно** исчерпывающий список составить невозможно, но я постараюсь включить как можно больше тем, подтем и направлений.

**Внимание!** Этот список ОЧЕНЬ длинный и детализированный. Используйте его как справочник, а не как построчный план изучения.

**I. Основы и Математический Аппарат**

1. **Введение в Алгоритмы:**
    *   Определение алгоритма.
    *   Свойства алгоритмов:
        *   Дискретность
        *   Детерминированность
        *   Результативность
        *   Массовость
        *   Понятность
        *   Корректность
    *   Способы записи алгоритмов:
        *   Словесное описание
        *   Блок-схемы
        *   Псевдокод
        *   Языки программирования
        *   Диаграммы Насси-Шнейдермана
    *   История развития теории алгоритмов:
        *   Алгоритм Евклида
        *   Работы Аль-Хорезми
        *   Лейбниц и идея механизации вычислений
        *   Алан Тьюринг и машина Тьюринга
        *   Появление первых компьютеров и языков программирования
        *   Развитие теории сложности вычислений
    *   Примеры алгоритмов из различных областей:
        *   Сортировка данных
        *   Поиск информации
        *   Шифрование
        *   Сжатие данных
        *   Обработка изображений
        *   Машинное обучение
    *   Эмпирический анализ алгоритмов
        *   Тестирование
        *   Бенчмаркинг
        *   Профилирование
        *   Визуализация

2. **Анализ Сложности Алгоритмов:**
    *   Временная сложность:
        *   Асимптотические обозначения:
            *   O-большое (верхняя граница)
            *   Ω-большое (нижняя граница)
            *   Θ-большое (точная оценка)
            *   o-малое (строгая верхняя граница)
            *   ω-малое (строгая нижняя граница)
            *   Свойства асимптотических обозначений
        *   Лучший, средний и худший случаи
        *   Методы анализа временной сложности:
            *   Подсчет количества элементарных операций
            *   Анализ циклов и рекурсии
            *   Рекуррентные соотношения:
                *   Метод подстановки
                *   Метод деревьев рекурсии
                *   Основная теорема о рекуррентных соотношениях (Master Theorem)
            *   Метод производящих функций
            *   Метод Амортизационного анализа (Amortized Analysis):
                *   Метод группировки (Aggregate method)
                *   Метод предоплаты (Accounting method)
                *   Метод потенциалов (Potential method)
    *   Пространственная сложность:
        *   Использование памяти алгоритмом
        *   Асимптотические обозначения для пространственной сложности
        *   Анализ пространственной сложности для рекурсивных алгоритмов
    *   Классы сложности:
        *   P (полиномиальное время)
        *   NP (недетерминированное полиномиальное время)
        *   NP-полные задачи (NP-complete)
        *   NP-трудные задачи (NP-hard)
        *   co-NP
        *   EXP (экспоненциальное время)
        *   PSPACE (полиномиальная память)
        *   EXPSPACE (экспоненциальная память)
        *   Иерархия классов сложности
        *   Сводимость задач (по Карпу, по Куку)
        *   Теорема Кука-Левина
    *   Проблема P = NP:
        *   Формулировка проблемы
        *   Значение для теоретической информатики и практики
        *   Подходы к решению
    *   Практическое значение анализа сложности:
        *   Выбор оптимального алгоритма для конкретной задачи
        *   Оптимизация алгоритмов по времени и памяти
        *   Разработка эффективных программ

3. **Математические Основы:**
    *   **Дискретная Математика:**
        *   Теория множеств:
            *   Операции над множествами
            *   Мощность множеств
            *   Отношения и функции
            *   Булевы функции
        *   Математическая логика:
            *   Исчисление высказываний
            *   Исчисление предикатов
            *   Кванторы
            *   Методы доказательств:
                *   Прямое доказательство
                *   Доказательство от противного
                *   Математическая индукция
        *   Комбинаторика:
            *   Правила суммы и произведения
            *   Перестановки
            *   Размещения
            *   Сочетания
            *   Биномиальные коэффициенты
            *   Принцип включений-исключений
            *   Рекуррентные соотношения в комбинаторике
        *   Теория графов:
            *   Основные определения (вершины, ребра, пути, циклы, степень вершины)
            *   Типы графов (ориентированные, неориентированные, взвешенные, связные, полные, двудольные)
            *   Деревья (корневые деревья, бинарные деревья, леса)
            *   Представление графов (матрица смежности, списки смежности, матрица инцидентности)
            *   Связность графов, компоненты связности
            *   Изоморфизм графов
        *   Рекуррентные соотношения:
            *   Линейные однородные рекуррентные соотношения с постоянными коэффициентами
            *   Линейные неоднородные рекуррентные соотношения
            *   Методы решения (характеристическое уравнение, производящие функции)
        *   Теория чисел:
            *   Делимость
            *   Простые числа
            *   Наибольший общий делитель (НОД)
            *   Наименьшее общее кратное (НОК)
            *   Алгоритм Евклида
            *   Модульная арифметика
            *   Китайская теорема об остатках
        *   Булева алгебра
    *   **Математический Анализ:**
        *   Пределы последовательностей и функций
        *   Непрерывность функций
        *   Производные:
            *   Определение и геометрический смысл
            *   Правила дифференцирования
            *   Производные элементарных функций
        *   Интегралы:
            *   Неопределенный интеграл
            *   Определенный интеграл
            *   Методы интегрирования
        *   Ряды:
            *   Числовые ряды
            *   Сходимость и расходимость рядов
            *   Признаки сходимости
            *   Степенные ряды
            *   Ряды Тейлора и Маклорена
    *   **Линейная Алгебра:**
        *   Векторы и матрицы:
            *   Операции над векторами и матрицами
            *   Линейная независимость векторов
            *   Базис и размерность векторного пространства
        *   Системы линейных уравнений:
            *   Метод Гаусса
            *   Метод Крамера
            *   Матричные уравнения
        *   Определители
        *   Обратная матрица
        *   Собственные значения и собственные векторы:
            *   Характеристический многочлен
            *   Диагонализация матрицы
        *   Линейные преобразования
    *   **Теория Вероятностей и Математическая Статистика:**
        *   Случайные события и вероятности
        *   Условная вероятность
        *   Независимость событий
        *   Формула Байеса
        *   Случайные величины:
            *   Дискретные и непрерывные случайные величины
            *   Функция распределения
            *   Плотность вероятности
        *   Математическое ожидание
        *   Дисперсия
        *   Стандартное отклонение
        *   Распределения вероятностей:
            *   Биномиальное распределение
            *   Распределение Пуассона
            *   Нормальное распределение
            *   Экспоненциальное распределение
        *   Закон больших чисел
        *   Центральная предельная теорема
        *   Статистические оценки
        *   Доверительные интервалы
        *   Проверка статистических гипотез

**II. Базовые Алгоритмы и Структуры Данных**

1. **Алгоритмы Сортировки:**
    *   Сортировка пузырьком (Bubble Sort):
        *   Алгоритм и его реализация
        *   Анализ временной и пространственной сложности
        *   Оптимизации (флаг обмена)
    *   Сортировка вставками (Insertion Sort):
        *   Алгоритм и его реализация
        *   Анализ сложности
        *   Применение для почти отсортированных данных
    *   Сортировка выбором (Selection Sort):
        *   Алгоритм и его реализация
        *   Анализ сложности
    *   Сортировка слиянием (Merge Sort):
        *   Алгоритм и его реализация (рекурсивная и итеративная версии)
        *   Анализ сложности
        *   Применение для внешней сортировки
    *   Быстрая сортировка (Quick Sort):
        *   Алгоритм и его реализация
        *   Выбор опорного элемента (pivot)
        *   Анализ сложности (лучший, средний, худший случаи)
        *   Оптимизации (случайный выбор опорного элемента, медиана из трех)
        *   Проблема деградации производительности
    *   Сортировка кучей (Heap Sort):
        *   Двоичная куча (binary heap) как структура данных
        *   Построение кучи (heapify)
        *   Алгоритм сортировки
        *   Анализ сложности
    *   Сортировка подсчетом (Counting Sort):
        *   Алгоритм и его реализация
        *   Ограничения на диапазон входных данных
        *   Анализ сложности
    *   Поразрядная сортировка (Radix Sort):
        *   Алгоритм и его реализация
        *   Сортировка по младшим и старшим разрядам (LSD, MSD)
        *   Анализ сложности
    *   Карманная сортировка (Bucket Sort):
        *   Алгоритм и его реализация
        *   Предположения о равномерном распределении входных данных
        *   Анализ сложности
    *   Внешняя сортировка:
        *   Сортировка данных, не помещающихся в оперативную память
        *   Многофазная сортировка
        *   Сортировка с использованием нескольких лент или дисков
    *   Сравнение алгоритмов сортировки:
        *   Сравнительная таблица по временной и пространственной сложности
        *   Устойчивость (stability) алгоритмов сортировки
        *   Выбор оптимального алгоритма в зависимости от характеристик данных и требований к производительности
    *   Нижняя граница времени сортировки сравнениями: Ω(n log n)
    *   Timsort
    *   Introsort

2. **Алгоритмы Поиска:**
    *   Линейный поиск:
        *   Алгоритм и его реализация
        *   Анализ сложности
    *   Двоичный поиск (бинарный поиск):
        *   Алгоритм и его реализация (рекурсивная и итеративная версии)
        *   Требование к отсортированности данных
        *   Анализ сложности
    *   Интерполяционный поиск:
        *   Алгоритм и его реализация
        *   Предположение о равномерном распределении данных
        *   Анализ сложности
    *   Поиск в деревьях:
        *   Бинарные деревья поиска (Binary Search Trees, BST):
            *   Вставка, удаление, поиск узла
            *   Анализ сложности (средний и худший случаи)
            *   Проблема вырожденных деревьев
        *   Сбалансированные деревья поиска:
            *   AVL-деревья:
                *   Балансировка с помощью вращений
                *   Вставка, удаление, поиск
                *   Анализ сложности
            *   Красно-черные деревья (Red-Black Trees):
                *   Свойства красно-черных деревьев
                *   Балансировка с помощью вращений и перекрашивания узлов
                *   Вставка, удаление, поиск
                *   Анализ сложности
            *   B-деревья:
                *   Предназначение для работы с внешней памятью
                *   Структура B-дерева
                *   Вставка, удаление, поиск
                *   Анализ сложности
            *   B+ деревья
        *   Другие виды деревьев:
            *   2-3-деревья
            *   2-3-4-деревья
            *   Splay-деревья
        *   Префиксные деревья (Trie):
            *   Структура и назначение
            *   Поиск, вставка, удаление слов
            *   Применение для автодополнения, проверки орфографии
        *   Деревья отрезков (Segment Trees):
            *   Структура и назначение
            *   Операции на отрезках (сумма, минимум, максимум)
            *   Модификации на отрезках
        *   Двоичная куча (Heap):
            *   Извлечение минимума/максимума
            *   Добавление элемента
            *   Heapify
        *   Дерево Фенвика
    *   Хеширование:
        *   Хеш-функции:
            *   Свойства хороших хеш-функций
            *   Методы построения хеш-функций (деление, умножение, универсальное хеширование)
        *   Хеш-таблицы:
            *   Разрешение коллизий:
                *   Метод цепочек (chaining)
                *   Открытая адресация:
                    *   Линейное пробирование
                    *   Квадратичное пробирование
                    *   Двойное хеширование
            *   Анализ сложности операций (поиск, вставка, удаление)
            *   Коэффициент заполнения (load factor)
        *   Идеальное хеширование
        *   Фильтр Блума

3. **Структуры Данных:**
    *   **Массивы:**
        *   Одномерные массивы:
            *   Доступ к элементам по индексу
            *   Вставка и удаление элементов (сдвиг)
        *   Многомерные массивы
        *   Динамические массивы:
            *   Изменение размера массива при необходимости
            *   Реализация (например, std::vector в C++)
            *   Амортизационный анализ операций
    *   **Списки:**
        *   Односвязные списки:
            *   Структура узла (данные и указатель на следующий узел)
            *   Вставка, удаление, поиск элементов
        *   Двусвязные списки:
            *   Структура узла (данные, указатели на следующий и предыдущий узлы)
            *   Вставка, удаление, поиск элементов
        *   Кольцевые списки
        *   Применение списков:
            *   Реализация стеков, очередей
            *   Представление разреженных матриц
    *   **Стеки:**
        *   Принцип LIFO (Last-In, First-Out)
        *   Операции: push (добавить элемент), pop (извлечь элемент), peek (посмотреть верхний элемент)
        *   Реализация на массиве и списке
        *   Применение стеков:
            *   Проверка баланса скобок
            *   Вычисление выражений в постфиксной записи
            *   Реализация рекурсии
            *   Алгоритмы на графах (поиск в глубину)
    *   **Очереди:**
        *   Принцип FIFO (First-In, First-Out)
        *   Операции: enqueue (добавить элемент), dequeue (извлечь элемент), front (посмотреть первый элемент)
        *   Реализация на массиве (с использованием кольцевого буфера) и списке
        *   Очереди с приоритетом (Priority Queues):
            *   Каждый элемент имеет приоритет
            *   Извлечение элемента с наивысшим (или наинизшим) приоритетом
            *   Реализация на основе кучи (heap)
        *   Дек (двусторонняя очередь, Deque):
            *   Добавление и удаление элементов с обоих концов
            *   Реализация на массиве и списке
        *   Применение очередей:
            *   Моделирование систем массового обслуживания
            *   Буферизация данных
            *   Алгоритмы на графах (поиск в ширину)
    *   **Деревья:**
        *   Основные понятия: корень, узел, лист, предок, потомок, высота, глубина
        *   Бинарные деревья:
            *   Представление бинарных деревьев
            *   Обход бинарных деревьев:
                *   Прямой (pre-order)
                *   Обратный (post-order)
                *   Центрированный (in-order)
                *   Уровневый (level-order)
            *   Полные и совершенные бинарные деревья
        *   Бинарные деревья поиска (BST)
        *   Сбалансированные деревья поиска:
            *   AVL-деревья
            *   Красно-черные деревья
            *   B-деревья
            *   B+ деревья
        *   Другие виды деревьев:
            *   2-3-деревья
            *   2-3-4-деревья
            *   Splay-деревья
        *   Префиксные деревья (Trie)
        *   Деревья отрезков (Segment Trees)
        *   Двоичная куча (Heap)
        *   Дерево Фенвика
    *   **Хеш-таблицы:**
        *   Хеш-функции
        *   Разрешение коллизий:
            *   Метод цепочек
            *   Открытая адресация
        *   Идеальное хеширование
        *   Динамическое хеширование
    *   **Графы:**
        *   Представления графов:
            *   Матрица смежности
            *   Списки смежности
            *   Матрица инцидентности
            *   Список ребер
        *   Взвешенные графы
    *   **Множества:**
        *   Реализация множеств с помощью битовых массивов
        *   Реализация множеств с помощью хеш-таблиц
        *   Реализация множеств с помощью сбалансированных деревьев поиска
    *   **Система непересекающихся множеств (Disjoint Set Union, DSU):**
        *   Структура данных для представления семейства непересекающихся множеств
        *   Операции:
            *   MakeSet(x) - создать новое множество, состоящее из одного элемента x
            *   Find(x) - найти "представителя" множества, которому принадлежит x
            *   Union(x, y) - объединить два множества, которым принадлежат x и y
        *   Реализации:
            *   Лес непересекающихся множеств
            *   Эвристика сжатия путей
            *   Ранговая эвристика
        *   Анализ сложности
        *   Применение:
            *   Алгоритм Краскала

**III. Основные Алгоритмические Парадигмы**

1. **"Разделяй и Властвуй" (Divide and Conquer):**
    *   Принцип метода:
        *   Разделение задачи на несколько подзадач меньшего размера
        *   Решение подзадач рекурсивно
        *   Комбинирование решений подзадач для получения решения исходной задачи
    *   Примеры:
        *   Бинарный поиск
        *   Сортировка слиянием
        *   Быстрая сортировка
        *   Нахождение выпуклой оболочки (алгоритм Грэхема, алгоритм Джарвиса)
        *   Умножение матриц (алгоритм Штрассена)
        *   Поиск ближайшей пары точек
    *   Рекурсия и рекуррентные соотношения
    *   Анализ сложности алгоритмов "разделяй и властвуй"
    *   Мастер-теорема (Master Theorem)

2. **Динамическое Программирование:**
    *   Принцип оптимальности подзадач
    *   Перекрывающиеся подзадачи
    *   Мемоизация (memoization):
        *   Сохранение результатов решения подзадач для избежания повторных вычислений
        *   Реализация с помощью таблиц или хеш-таблиц
    *   Табличный метод (tabulation):
        *   Построение таблицы решений подзадач в восходящем порядке
    *   Примеры:
        *   Числа Фибоначчи
        *   Задача о рюкзаке (knapsack problem):
            *   Дискретная задача о рюкзаке (0/1 knapsack)
            *   Непрерывная задача о рюкзаке (fractional knapsack)
        *   Наибольшая общая подпоследовательность (Longest Common Subsequence, LCS)
        *   Наибольшая возрастающая подпоследовательность (Longest Increasing Subsequence, LIS)
        *   Расстояние Левенштейна (редакционное расстояние, edit distance)
        *   Задача о выравнивании последовательностей (sequence alignment)
        *   Задача о порядке перемножения матриц (matrix chain multiplication)
        *   Задача о триангуляции многоугольника
        *   Алгоритм Флойда-Уоршелла
        *   Алгоритм Беллмана-Форда
    *   Восстановление решения:
        *   Сохранение дополнительной информации для восстановления оптимального решения, а не только его стоимости
    *   Динамическое программирование по подмножествам
    *   Динамическое программирование на деревьях

3. **Жадные Алгоритмы (Greedy Algorithms):**
    *   Принцип локальной оптимальности:
        *   На каждом шаге выбирается локально-оптимальное решение в надежде, что это приведет к глобально-оптимальному решению
    *   Когда жадный алгоритм дает оптимальное решение:
        *   Свойство жадного выбора (greedy choice property)
        *   Свойство оптимальности подструктуры (optimal substructure property)
        *   Матроиды
    *   Примеры:
        *   Алгоритм Прима (минимальное остовное дерево)
        *   Алгоритм Краскала (минимальное остовное дерево)
        *   Алгоритм Дейкстры (кратчайшие пути в графе)
        *   Код Хаффмана (сжатие данных)
        *   Задача о выборе заявок (activity selection problem)
        *   Размен монет (coin change problem)
        *   Непрерывная задача о рюкзаке
    *   Эвристики:
        *   Жадные алгоритмы могут использоваться как эвристики для задач, где они не гарантируют оптимальное решение
    *   Приближенные алгоритмы на основе жадных методов

4. **Полный Перебор (Brute-Force):**
    *   Метод грубой силы:
        *   Перебор всех возможных решений задачи и выбор лучшего из них
    *   Примеры:
        *   Задача коммивояжера (полный перебор всех перестановок городов)
        *   Задача о рюкзаке (перебор всех подмножеств предметов)
        *   Задача о выполнимости булевой формулы (SAT)
        *   Поиск подстроки в строке (наивный алгоритм)
        *   Сортировка выбором
    *   Ограничения метода:
        *   Экспоненциальная сложность для многих задач
        *   Неприменимость для задач с большим размером входных данных
    *   Методы оптимизации перебора:
        *   Отсечения (pruning):
            *   Отбрасывание заведомо неоптимальных решений
        *   Эвристики:
            *   Использование эвристик для сокращения пространства поиска
        *   Рандомизация:
            *   Случайный порядок перебора
    *   Поиск с возвратом (Backtracking):
        *   Построение решения по частям с возвратом назад при неудаче
        *   Примеры:
            *   Задача о расстановке ферзей
            *   Задача о раскраске графа
            *   Задача о гамильтоновом цикле
            *   Решение судоку
        *   Реализация с помощью рекурсии
        *   Отсечения в поиске с возвратом
    *   Метод ветвей и границ (Branch and Bound):
        *   Примеры задач:
            *   Целочисленное линейное программирование
            *   Задача коммивояжера
        *   Оценка верхней и нижней границы для отсечения ветвей:
            *   Методы получения оценок (релаксация, эвристики)
        *   Стратегии ветвления
        *   Применение к задачам оптимизации
        *   A*-поиск
            *   Использование эвристической функции для направления поиска
            *   Применение в задачах поиска пути на графе, искусственном интеллекте

**IV. Алгоритмы на Графах**

1. **Обход Графов:**
    *   Поиск в глубину (Depth-First Search, DFS):
        *   Алгоритм и его реализация (рекурсивная и итеративная с использованием стека)
        *   Раскраска вершин (белый, серый, черный цвета)
        *   Время открытия и закрытия вершин
        *   Классификация ребер (ребра дерева, обратные, прямые, поперечные)
        *   Применения:
            *   Проверка связности графа
            *   Поиск циклов
            *   Топологическая сортировка
            *   Поиск компонент сильной связности
            *   Поиск мостов и точек сочленения
    *   Поиск в ширину (Breadth-First Search, BFS):
        *   Алгоритм и его реализация (с использованием очереди)
        *   Раскраска вершин
        *   Дерево поиска в ширину
        *   Применения:
            *   Поиск кратчайшего пути в невзвешенном графе
            *   Поиск компонент связности
            *   Проверка двудольности графа
            *   Построение конденсации графа
            *   Сборщик мусора

2. **Кратчайшие Пути:**
    *   Алгоритм Дейкстры (Dijkstra's algorithm):
        *   Ограничение: неотрицательные веса ребер
        *   Алгоритм и его реализация (с использованием очереди с приоритетами)
        *   Анализ сложности
        *   Применение:
            *   Поиск кратчайших путей в дорожных сетях, компьютерных сетях
    *   Алгоритм Беллмана-Форда (Bellman-Ford algorithm):
        *   Работает с ребрами отрицательного веса
        *   Алгоритм и его реализация
        *   Обнаружение отрицательных циклов
        *   Анализ сложности
    *   Алгоритм Флойда-Уоршелла (Floyd-Warshall algorithm):
        *   Нахождение кратчайших путей между всеми парами вершин
        *   Динамическое программирование
        *   Алгоритм и его реализация
        *   Анализ сложности
        *   Работает с отрицательными весами, но без отрицательных циклов.
    *   Алгоритм Джонсона (Johnson's algorithm):
        *   Нахождение кратчайших путей между всеми парами вершин в разреженных графах
        *   Использование алгоритма Беллмана-Форда для перевзвешивания ребер и последующее применение алгоритма Дейкстры
        *   Анализ сложности
    *   Алгоритм A* (A-star):
        *   Эвристический алгоритм поиска кратчайшего пути
        *   Функция оценки: f(n) = g(n) + h(n)
        *   Применение в задачах искусственного интеллекта, робототехнике
    *   Алгоритмы для динамических графов
    *   Алгоритмы поиска k-кратчайших путей
    *   Двунаправленный поиск

3. **Минимальное Остовное Дерево (Minimum Spanning Tree, MST):**
    *   Определение остовного дерева
    *   Определение минимального остовного дерева
    *   Лемма о безопасном ребре
    *   Алгоритм Прима (Prim's algorithm):
        *   Жадный алгоритм
        *   Алгоритм и его реализация (с использованием очереди с приоритетами)
        *   Анализ сложности
    *   Алгоритм Краскала (Kruskal's algorithm):
        *   Жадный алгоритм
        *   Использование системы непересекающихся множеств (DSU)
        *   Алгоритм и его реализация
        *   Анализ сложности
    *   Алгоритм Борувки
    *   Применения:
        *   Построение сетей (дорожных, компьютерных, электрических) с минимальной стоимостью
        *   Кластеризация данных

4. **Связность:**
    *   Компоненты связности:
        *   Нахождение компонент связности с помощью DFS или BFS
    *   Сильно связные компоненты (Strongly Connected Components, SCC):
        *   Определение сильно связного графа и сильно связных компонент
        *   Алгоритм Косарайю (Kosaraju's algorithm)
        *   Алгоритм Тарьяна (Tarjan's algorithm)
        *   Применения:
            *   Анализ социальных сетей
            *   Анализ графов зависимостей
    *   Мосты (Bridges):
        *   Определение моста
        *   Нахождение мостов с помощью модифицированного DFS
    *   Точки сочленения (Articulation Points):
        *   Определение точки сочленения
        *   Нахождение точек сочленения с помощью модифицированного DFS
    *   Двусвязные компоненты
    *   k-связные графы
    *   k-реберно связные графы

5. **Потоки в Сетях (Network Flows):**
    *   Постановка задачи о максимальном потоке:
        *   Сеть (flow network)
        *   Источник (source) и сток (sink)
        *   Пропускная способность ребер (capacity)
        *   Поток (flow)
        *   Величина потока
        *   Задача о максимальном потоке (maximum flow problem)
    *   Разрез (cut):
        *   Определение разреза
        *   Пропускная способность разреза
        *   Минимальный разрез (minimum cut)
    *   Остаточная сеть (residual network):
        *   Определение остаточной сети
        *   Остаточная пропускная способность
        *   Дополняющий путь (augmenting path)
    *   Теорема Форда-Фалкерсона:
        *   Условие максимальности потока: отсутствие дополняющих путей в остаточной сети
        *   Связь максимального потока и минимального разреза
    *   Алгоритм Форда-Фалкерсона (Ford-Fulkerson algorithm):
        *   Нахождение дополняющих путей с помощью DFS или BFS
        *   Анализ сложности (проблема с иррациональными пропускными способностями)
    *   Алгоритм Эдмондса-Карпа (Edmonds-Karp algorithm):
        *   Выбор кратчайшего дополняющего пути (с помощью BFS)
        *   Полиномиальная сложность
    *   Алгоритм Диница
    *   Алгоритм "проталкивания предпотока" (Push-Relabel algorithm)
    *   Задача о минимальном разрезе
    *   Задача о многопродуктовом потоке (Multicommodity flow)
    *   Применения:
        *   Транспортные задачи
        *   Задачи распределения ресурсов
        *   Задачи нахождения максимального паросочетания в двудольном графе

6. **Паросочетания (Matchings):**
    *   Определение паросочетания
    *   Максимальное паросочетание (maximum matching)
    *   Совершенное паросочетание (perfect matching)
    *   Наибольшее паросочетание
    *   Задача о максимальном паросочетании в двудольном графе:
        *   Сведение к задаче о максимальном потоке
        *   Алгоритм Куна (Kuhn's algorithm)
        *   Венгерский алгоритм (Hungarian algorithm)
    *   Задача о стабильном паросочетании (Stable Marriage Problem)
        *   Алгоритм Гейла-Шепли
    *   Взвешенные паросочетания
        *   Задача о назначениях
    *   Паросочетания в произвольных графах
        *   Алгоритм Эдмондса (цветов)

7. **Эйлеровы и Гамильтоновы Циклы (продолжение):**
    *   Эйлеровы графы и циклы (продолжение):
        *   Критерий существования эйлерова цикла (связность и четность степеней всех вершин)
        *   Критерий существования эйлерова пути (связность и не более двух вершин нечетной степени)
        *   Алгоритм Флёри (Fleury's algorithm)
        *   Алгоритм, основанный на поиске в глубину
        *   Применения:
            *   Задача о кенигсбергских мостах
            *   Построение оптимальных маршрутов (например, для уборки улиц)
    *   Гамильтоновы графы и циклы:
        *   Определение гамильтонова пути и гамильтонова цикла
        *   NP-полнота задачи определения гамильтонова цикла
        *   Достаточные условия существования гамильтонова цикла (теорема Дирака, теорема Оре)
        *   Методы решения задачи о гамильтоновом цикле:
            *   Полный перебор
            *   Метод ветвей и границ
            *   Эвристические алгоритмы
        *   Применения:
            *   Задача коммивояжера
            *   Задачи маршрутизации
    *   Связь эйлеровых и гамильтоновых циклов

8. **Раскраска Графов:**
    *   Определение раскраски графа
    *   Хроматическое число (chromatic number)
    *   Задача о раскраске графа (graph coloring problem)
    *   NP-полнота задачи определения хроматического числа
    *   Жадный алгоритм раскраски:
        *   Последовательная раскраска вершин
        *   Анализ качества раскраски
    *   Алгоритм Велша-Пауэлла
    *   Раскраска ребер графа
    *   Хроматический индекс
    *   Теорема Визинга
    *   Применения:
        *   Составление расписаний
        *   Распределение частот в радиосетях
        *   Размещение объектов на карте

9. **Планарные Графы:**
    *   Определение планарного графа
    *   Укладка графа на плоскости
    *   Формула Эйлера для планарных графов (V - E + F = 2)
    *   Теорема Понтрягина-Куратовского:
        *   Критерий планарности графа (отсутствие подграфов, гомеоморфных K5 или K3,3)
    *   Алгоритмы проверки планарности графа
    *   Раскраска планарных графов:
        *   Теорема о четырех красках
    *   Применения:
        *   Разработка печатных плат
        *   Визуализация графов

10. **Деревья:**
    *   Определение дерева
    *   Свойства деревьев (связность, отсутствие циклов, количество ребер = количество вершин - 1)
    *   Корневые деревья
    *   Центр дерева
    *   Диаметр дерева
    *   Обходы деревьев (pre-order, in-order, post-order, level-order)
    *   Кодирование деревьев (код Прюфера)
    *   Задача о минимальном остовном дереве
    *   Деревья поиска
    *   Применения:
        *   Представление иерархических данных
        *   Алгоритмы поиска
        *   Сжатие данных (код Хаффмана)

11. **Другие Задачи на Графах:**
    *   Задача о клике (clique problem)
    *   Задача о вершинном покрытии (vertex cover problem)
    *   Задача о независимом множестве (independent set problem)
    *   Задача о доминирующем множестве (dominating set problem)
    *   Задача о изоморфизме графов
    *   Задача о максимальном разрезе

**V. Продвинутые Темы**

1. **Геометрические Алгоритмы:**
    *   Введение в вычислительную геометрию
    *   Представление геометрических объектов (точки, отрезки, многоугольники)
    *   Базовые операции:
        *   Определение взаимного расположения точек и отрезков
        *   Пересечение отрезков
        *   Проверка принадлежности точки многоугольнику
    *   Выпуклая оболочка (convex hull):
        *   Определение выпуклой оболочки
        *   Алгоритмы построения выпуклой оболочки:
            *   Алгоритм Грэхема
            *   Алгоритм Джарвиса (заворачивание подарка)
            *   Алгоритм quickhull
            *   Алгоритм «разделяй и властвуй»
        *   Применения:
            *   Компьютерная графика
            *   Распознавание образов
            *   Робототехника
    *   Диаграмма Вороного (Voronoi diagram):
        *   Определение диаграммы Вороного
        *   Алгоритм Форчуна
        *   Применения:
            *   Поиск ближайшего соседа
            *   Планирование пути в робототехнике
            *   Моделирование роста кристаллов
    *   Триангуляция Делоне (Delaunay triangulation):
        *   Определение триангуляции Делоне
        *   Связь с диаграммой Вороного
        *   Алгоритмы построения триангуляции Делоне
        *   Применения:
            *   Генерация сеток для численных методов
            *   Моделирование рельефа местности
    *   Поиск ближайшей пары точек:
        *   Алгоритм «разделяй и властвуй»
        *   Анализ сложности
    *   Пересечение геометрических фигур
    *   Локализация точки
    *   Задача о принадлежности точки многоугольнику:
        *   Метод трассировки луча
        *   Метод суммирования углов
    *   Задача о построении многоугольника по заданному множеству точек
    *   Симплициальные комплексы
    *   Топологический анализ данных

2. **Строковые Алгоритмы:**
    *   Поиск подстроки в строке:
        *   Наивный алгоритм
        *   Алгоритм Кнута-Морриса-Пратта (KMP):
            *   Префикс-функция
            *   Построение префикс-функции
            *   Алгоритм поиска
            *   Анализ сложности
        *   Алгоритм Бойера-Мура (Boyer-Moore):
            *   Эвристика стоп-символа
            *   Эвристика совпавшего суффикса
            *   Алгоритм поиска
            *   Анализ сложности
        *   Алгоритм Рабина-Карпа (Rabin-Karp):
            *   Использование хеширования
            *   Алгоритм поиска
            *   Анализ сложности
        *   Алгоритм Ахо-Корасик (Aho-Corasick)
            *   Поиск множества подстрок в строке
            *   Построение бора (trie) с суффиксными ссылками
        *   Суффиксный массив
        *   Суффиксное дерево
    *   Расстояние Левенштейна (редакционное расстояние, edit distance):
        *   Определение расстояния Левенштейна
        *   Алгоритм Вагнера-Фишера (динамическое программирование)
        *   Восстановление выравнивания
        *   Применения:
            *   Проверка орфографии
            *   Распознавание речи
            *   Биоинформатика
    *   Выравнивание последовательностей (sequence alignment):
        *   Глобальное выравнивание (алгоритм Нидлмана-Вунша)
        *   Локальное выравнивание (алгоритм Смита-Ватермана)
        *   Множественное выравнивание последовательностей
        *   Применения в биоинформатике
    *   Алгоритмы сжатия данных:
        *   Код Хаффмана:
            *   Построение дерева Хаффмана
            *   Кодирование и декодирование
        *   Алгоритм Лемпеля-Зива (LZ77, LZ78, LZW):
            *   Принцип работы
            *   Применения
        *   Преобразование Барроуза-Уилера (Burrows-Wheeler transform)
    *   Регулярные выражения
    *   Синтаксический анализ

3. **Параллельные Алгоритмы:**
    *   Модели параллельных вычислений:
        *   PRAM (Parallel Random Access Machine):
            *   EREW, CREW, CRCW
            *   Моделирование параллельных вычислений на PRAM
        *   BSP (Bulk Synchronous Parallel)
        *   Сети (interconnection networks):
            *   Топологии сетей (линейная, кольцо, звезда, решетка, гиперкуб)
        *   Модель коммуникации с общей памятью
        *   Модель коммуникации с передачей сообщений
    *   Параллельная сложность
        *   Время работы
        *   Количество процессоров
        *   Ускорение (speedup)
        *   Эффективность (efficiency)
        *   Стоимость (cost)
        *   Закон Амдала
        *   Закон Густавсона-Барсиса
    *   Параллельные алгоритмы сортировки:
        *   Сортировка слиянием
        *   Быстрая сортировка
        *   Поразрядная сортировка
        *   Четно-нечетная сортировка
    *   Параллельные алгоритмы на графах:
        *   Поиск в ширину
        *   Поиск в глубину
        *   Нахождение компонент связности
        *   Нахождение минимального остовного дерева
    *   Параллельные алгоритмы для матричных операций:
        *   Умножение матриц
        *   Решение систем линейных уравнений
    *   Параллельное динамическое программирование
    *   Распределенные алгоритмы
        *   Консенсус
        *   Выборы лидера
        *   Взаимное исключение
    *   Параллельные алгоритмы в машинном обучении

4. **Вероятностные (Рандомизированные) Алгоритмы:**
    *   Генерация случайных чисел:
        *   Линейный конгруэнтный метод
        *   Вихрь Мерсенна
        *   Криптографически стойкие генераторы случайных чисел
    *   Метод Монте-Карло:
        *   Приближенное вычисление значений с использованием случайных выборок
        *   Применения:
            *   Численное интегрирование
            *   Моделирование физических процессов
            *   Финансовое моделирование
    *   Вероятностные алгоритмы для проверки свойств:
        *   Тест простоты числа (тест Миллера-Рабина)
        *   Проверка равенства многочленов
        *   Проверка равенства строк
    *   Рандомизированный алгоритм поиска медианы:
        *   Алгоритм Quickselect
        *   Анализ сложности
    *   Рандомизированный алгоритм быстрой сортировки
    *   Рандомизированные алгоритмы для задач на графах
        *   Нахождение минимального разреза (алгоритм Каргера)
    *   Алгоритмы Лас-Вегаса и Монте-Карло:
        *   Отличие в гарантиях точности и времени работы
    *   Вероятностный анализ алгоритмов
        *   Анализ среднего времени работы
    *   Применения:
        *   Криптография
        *   Тестирование программного обеспечения
        *   Оптимизация
        *   Машинное обучение

5. **Приближенные Алгоритмы:**
    *   Задачи, для которых сложно найти точное решение за полиномиальное время (NP-трудные задачи)
    *   Определение приближенного алгоритма
    *   Коэффициент аппроксимации:
        *   Отношение стоимости решения, полученного приближенным алгоритмом, к стоимости оптимального решения
        *   Константный коэффициент аппроксимации
        *   Логарифмический коэффициент аппроксимации
        *   Полиномиальный коэффициент аппроксимации
    *   Схемы аппроксимации:
        *   PTAS (Polynomial-Time Approximation Scheme)
        *   FPTAS (Fully Polynomial-Time Approximation Scheme)
    *   Примеры задач и приближенных алгоритмов:
        *   Задача о вершинном покрытии:
            *   2-приближенный алгоритм
        *   Задача о покрытии множества:
            *   ln(n)-приближенный жадный алгоритм
        *   Задача коммивояжера:
            *   2-приближенный алгоритм для метрической задачи коммивояжера
            *   1.5-приближенный алгоритм Кристофидеса
        *   Задача о рюкзаке:
            *   FPTAS для задачи о рюкзаке
        *   Задача об упаковке в контейнеры (bin packing):
            *   First-Fit, Best-Fit эвристики
    *   Методы разработки приближенных алгоритмов:
        *   Жадные алгоритмы
        *   Локальный поиск
        *   Линейное программирование и округление
        *   Рандомизированное округление
    *   Невозможность аппроксимации для некоторых задач
    *   Связь с параметризованными алгоритмами

6. **Квантовые Алгоритмы:**
    *   Основы квантовых вычислений:
        *   Кубиты
        *   Суперпозиция
        *   Квантовая запутанность
        *   Квантовые вентили
        *   Квантовые схемы
    *   Алгоритм Шора (Shor's algorithm):
        *   Факторизация чисел за полиномиальное время
        *   Дискретное логарифмирование за полиномиальное время
        *   Влияние на криптографию с открытым ключом
    *   Алгоритм Гровера (Grover's algorithm):
        *   Поиск в неупорядоченной базе данных за O(sqrt(N))
        *   Применения:
            *   Ускорение переборных алгоритмов
    *   Квантовые алгоритмы для задач оптимизации
    *   Квантовая телепортация
    *   Квантовая криптография
    *   Модели квантовых вычислений
    *   Ограничения квантовых вычислений

7. **Вычислительная Сложность:**
    *   Машина Тьюринга:
        *   Детерминированная машина Тьюринга
        *   Недетерминированная машина Тьюринга
        *   Универсальная машина Тьюринга
    *   Тезис Чёрча-Тьюринга
    *   Классы сложности:
        *   P
        *   NP
        *   co-NP
        *   NP-complete
        *   NP-hard
        *   PSPACE
        *   EXPTIME
        *   EXPSPACE
        *   BPP
        *   ZPP
        *   RP
        *   BQP
    *   Иерархия классов сложности
    *   Сводимость задач:
        *   Сводимость по Карпу
        *   Сводимость по Куку
    *   Теорема Кука-Левина:
        *   Сводимость любой задачи из NP к задаче SAT
    *   Доказательства NP-полноты:
        *   Сведение известных NP-полных задач к новой задаче
    *   Примеры NP-полных задач:
        *   Задача о выполнимости булевой формулы (SAT)
        *   Задача о 3-выполнимости (3-SAT)
        *   Задача о клике
        *   Задача о вершинном покрытии
        *   Задача о гамильтоновом цикле
        *   Задача о рюкзаке
        *   Задача о раскраске графа
    *   Проблема P = NP
    *   Теорема об иерархии по времени
    *   Теорема об иерархии по памяти
    *   Теория сложности схем
    *   Сложность по Колмогорову

8. **Теория Автоматов и Формальные Языки:**
    *   Конечные автоматы:
        *   Детерминированные конечные автоматы (DFA)
        *   Недетерминированные конечные автоматы (NFA)
        *   Эквивалентность DFA и NFA
        *   Минимизация DFA
        *   Регулярные языки
        *   Регулярные выражения
        *   Лемма о накачке для регулярных языков
    *   Контекстно-свободные грамматики:
        *   Определение контекстно-свободной грамматики
        *   Нормальная форма Хомского
        *   Нисходящий и восходящий разбор
        *   Алгоритм CYK
        *   Контекстно-свободные языки
        *   Лемма о накачке для контекстно-свободных языков
    *   Автоматы с магазинной памятью (Pushdown Automata):
        *   Эквивалентность автоматов с магазинной памятью и контекстно-свободных грамматик
    *   Машины Тьюринга
    *   Иерархия Хомского:
        *   Связь между типами формальных грамматик и классами автоматов
    *   Разрешимые и неразрешимые проблемы
    *   Проблема останова
    *   Применения:
        *   Теория компиляторов
        *   Обработка естественного языка

**VI. Практические Аспекты**

1. **Реализация Алгоритмов:**
    *   Выбор языка программирования:
        *   C/C++ для производительности
        *   Python для быстроты прототипирования
        *   Java для кросс-платформенности
        *   Другие языки (Go, Rust, etc.)
    *   Эффективность реализации:
        *   Оптимизация кода
        *   Использование эффективных структур данных
        *   Профилирование кода
    *   Отладка и тестирование:
        *   Модульное тестирование (unit testing)
        *   Интеграционное тестирование
        *   Отладчики
    *   Профилирование кода:
        *   Инструменты профилирования
        *   Выявление узких мест в производительности
    *   Верификация программного обеспечения
2. **Применение Алгоритмов в Реальных Задачах:**
    *   Машинное обучение:
        *   Регрессия
        *   Классификация
        *   Кластеризация
        *   Понижение размерности
        *   Глубокое обучение
    *   Компьютерное зрение:
        *   Обработка изображений
        *   Распознавание объектов
        *   Сегментация изображений
    *   Обработка естественного языка:
        *   Токенизация
        *   Синтаксический анализ
        *   Машинный перевод
        *   Извлечение информации
        *   Анализ тональности
    *   Биоинформатика:
        *   Выравнивание последовательностей
        *   Построение филогенетических деревьев
        *   Предсказание структуры белков
    *   Криптография:
        *   Шифрование с симметричным ключом
        *   Шифрование с открытым ключом
        *   Цифровые подписи
        *   Хеш-функции
    *   Базы данных:
        *   Индексирование
        *   Оптимизация запросов
        *   Транзакции
    *   Операционные системы:
        *   Планирование процессов
        *   Управление памятью
        *   Файловые системы
    *   Компиляторы:
        *   Лексический анализ
        *   Синтаксический анализ
        *   Оптимизация кода
    *   Игровая индустрия:
        *   Поиск пути
        *   Искусственный интеллект
        *   Физический движок
    *   Сетевые технологии
    *   Робототехника
    *   Финансовое моделирование
3. **Библиотеки Алгоритмов:**
    *   Стандартная библиотека языка:
        *   STL (C++)
        *   Collections (Java)
        *   Стандартная библиотека Python
    *   Специализированные библиотеки:
        *   NumPy (Python) - линейная алгебра, матричные операции
        *   SciPy (Python) - научные вычисления
        *   Pandas (Python) - обработка и анализ данных
        *   OpenCV (C++, Python) - компьютерное зрение
        *   TensorFlow, PyTorch (Python) - глубокое обучение
        *   NLTK (Python) - обработка естественного языка
        *   Scikit-learn (Python) - машинное обучение
        *   Boost (C++) - различные алгоритмы и структуры данных
        *   LEDA (C++) - библиотека алгоритмов и структур данных
        *   CGAL (C++) - библиотека алгоритмов вычислительной геометрии
    *   Использование библиотек:
        *   Преимущества:
            *   Экономия времени на разработку
            *   Надежность и эффективность
        *   Недостатки:
            *   Зависимость от сторонних библиотек
            *   Возможная избыточность функционала


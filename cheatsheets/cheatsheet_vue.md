### Следующий тик: Ожидание обновления DOM

Vue предоставляет нам удобный способ подождать, пока DOM завершит обновление:

```javascript
// Выполните действие, которое заставит Vue перерисовать
changeTheDOM();
// Ожидание завершения перерисовки
await nextTick();
// Теперь мы можем проверить только что обновленный DOM
inspectTheDOM();
```

Или, если вы используете Options API:

```javascript
await this.$nextTick();
```

Тик представляет собой один цикл отрисовки. Сначала Vue слушает любые изменения реактивности, затем выполняет несколько обновлений DOM пакетом. Затем начинается следующий тик.
Если вы обновляете что-то в своем приложении, что изменит то, что отображается, вам нужно подождать до следующего тика, прежде чем эти изменения будут видны.

### Private properties with script setup

```javascript
export default {
  expose: ['makeItPublic'],
  data() {
    return {
      privateData: 'Keep me a secret!',
    };
  },
  computed: {
    makeItPublic() {
      return this.privateData.toUpperCase();
    },
  },
};
```

```vue
<script setup>
import { ref, computed, defineExpose } from 'vue';

const privateData = ref('Keep me a secret!');
const makeItPublic = computed(() => privateData.value.toUpperCase());

// We don't need to import this because it's a compiler macro
defineExpose({ makeItPublic });
</script>

```

### Функции h и Render
При использовании функции **render** вместо шаблонов, вы будете часто использовать функцию **h**:

```html
<script setup>
import { h } from 'vue';
const render = () => h('div', {}, 'Hello Wurld');
</script>
```

С **Options API**, функция **render** работает точно так же, просто немного иначе определяется:

```html
<script>
import { h } from 'vue';
export default {
  render() {
    return h('div', {}, 'Hello Wurld');
  }
}
</script>
```

Она создает VNode (виртуальный узел), объект, который Vue внутренне использует для отслеживания обновлений и того, что он должен отрисовывать.

Первый аргумент - это имя элемента HTML или компонент (который может быть асинхронным, если вы хотите):

```html
<script setup>
import { h } from 'vue';
import MyComponent from './MyComponent.vue';
const render = () => h(MyComponent, {}, []);
</script>
```

#### 5 Забытых особенностей

Второй аргумент - это список свойств, атрибутов и обработчиков событий:

```html
<script setup>
import { h } from 'vue';
import MyComponent from './MyComponent.vue';
const render = () => h(MyComponent, {
  class: 'text-blue-400',
  title: 'Компонент - великий',
  onClick() {
    console.log('Кликнули!');
  },
}, []);
</script>
```

Третий аргумент - это либо строка для текстового узла, массив дочерних VNodes, либо объект для определения слотов:

```html
<script setup>
import { h } from 'vue';
import MyComponent from './MyComponent.vue';
const render = () => h(MyComponent, {}, [
  'Простой текстовый узел',
  h('span', {}, 'Текст внутри элемента <span>'),
]);
</script>
```

Эти функции **render** по сути то, что происходит "под капотом", когда Vue компилирует ваши компоненты с одиночным файлом для выполнения в браузере.

Но, написав функцию **render** самостоятельно, вы больше не ограничены тем, что можно сделать в шаблоне. У вас есть полная мощь JavaScript у вас на пальцах.

Это только малая часть того, что могут сделать функции **render** и **h**. Прочтите больше об этом онлайн.

### Директивы в функциях рендеринга

Vue поставляется со специальными методами, которые помогают вам использовать пользовательские директивы на ваших узлах VNodes:

```javascript
<script setup>
import { resolveDirective, withDirectives, h } from 'vue';
// Найдите уже зарегистрированную директиву по имени
const focusDirective = resolveDirective('focus');
// Оберните кнопку директивой
const render = () => withDirectives(
  h('button', {}, []),
  // Массив директив для применения
  [
    [focusDirective]
  ]
);
</script>
```

Функции рендеринга определяются немного по-другому при использовании API Опций:

```javascript
import { resolveDirective, withDirectives, h } from 'vue';
export default {
  render() {
    // Найдите уже зарегистрированную директиву по имени
    const focusDirective = resolveDirective('focus');
    // Оберните кнопку директивой
    return withDirectives(
      h('button', {}, []),
      // Массив директив для применения
      [
        [focusDirective]
      ]
    );
  }
}
```

Дополнительную информацию о использовании `withDirectives` вы можете найти в документации.


### Custom Directives

В скриптовой настройке вы можете определить пользовательскую директиву, просто дав ей имя в camelCase, начинающееся с `v`:

```html
<script setup>
const vRedBackground = {
  mounted: (el) => el.style.background = 'red',
}
</script>

<template>
  <input v-red-background />
</template>
```

С использованием API Опции:

```javascript
export default {
  setup() {
    // ...
  },
  directives: {
    redBackground: {
      mounted: (el) => el.style.background = 'red',
    },
  },
}
```

Регистрация директивы глобально:

```javascript
const app = createApp({})

// делаем `v-focus` доступным во всех компонентах
app.directive('redBackground', {
  mounted: (el) => el.style.background = 'red',
})
```

И поскольку очень часто возникает ситуация, когда логика для хуков `mounted` и `updated` одинакова, мы можем использовать функцию вместо объекта, которая будет выполняться для обоих:

```html
<script setup>
const vRedBackground = (el) => el.style.background = 'red';
</script>

<template>
  <input v-red-background />
</template>
```

### Deep Linking с Vue Router

Вы можете сохранить (частичное) состояние в URL, позволяющее перейти прямо к определенному состоянию на странице.

Например, вы можете загрузить страницу, где уже выбран фильтр диапазона даты:

`someurl.com/edit?date-range=last-week`

Это отлично подходит для частей вашего приложения, где пользователи могут делиться ссылками, а также для серверно-рендерингового приложения или для передачи большего объема информации между двумя приложениями, чем обычная ссылка.

Вы можете сохранить фильтры, значения поиска, открытые/закрытые модальные окна или позицию прокрутки в списке, что идеально подходит для бесконечной пагинации.

Получение значения запроса с помощью Vue Router работает так (это будет работать во многих фреймворках Vue, таких как Nuxt и Vuepress):

```javascript
// Composition API
const dateRange = useRoute().query.dateRange;

// Options API
const dateRange = this.$route.query.dateRange;
```

Чтобы изменить его, используйте компонент RouterLink и обновите запрос:

```html
<RouterLink :to="{
  query: {
    dateRange: newDateRange
  }
}">
```

### Деструктуризация в v-for

Вы знали, что можно использовать деструктуризацию в `v-for`?

```html
<li v-for="{ name, id } in users" :key="id">
  {{ name }}
</li>
```

Также известно, что можно получить индекс из `v-for`, используя кортеж:

```html
<li v-for="(movie, index) in [
  'Lion King',
  'Frozen',
  'The Princess Bride'
]">
  {{ index + 1 }} - {{ movie }}
</li>
```

Когда используется объект, можно также получить ключ:

```html
<li v-for="(value, key) in {
  name: 'Lion King',
  released: 2019,
  director: 'Jon Favreau',
}">
  {{ key }}: {{ value }}
</li>
```

Можно объединить эти два способа, получив и ключ, и индекс свойства:

```html
<li v-for="(value, key, index) in {
  name: 'Lion King',
  released: 2019,
  director: 'Jon Favreau',
}">
  #{{ index + 1 }}. {{ key }}: {{ value }}
</li>
```

### Глобальные компоненты

При регистрации компонента глобально вы можете использовать его в любом шаблоне без необходимости импорта:

```javascript
// Vue 3
import { createApp } from 'vue';
import GlobalComponent from './GlobalComponent.vue';

const app = createApp({});
app.component('GlobalComponent', GlobalComponent);
```

В Vue 2 глобальные компоненты регистрируются так:

```javascript
// Vue 2
import Vue from 'vue';
import GlobalComponent from './GlobalComponent.vue';

Vue.component('GlobalComponent', GlobalComponent);
```

Теперь вы можете использовать `GlobalComponent` в ваших шаблонах без дополнительных действий! Конечно, глобально зарегистрированные компоненты имеют свои преимущества и недостатки, поэтому используйте их с умеренностью.

### Ожидание обновления DOM с помощью nextTick

Vue предоставляет удобный способ ожидать завершения обновления DOM:

```javascript
// Выполните действие, которое приведет к повторному рендерингу Vue
changeTheDOM();

// Ожидайте завершения повторного рендеринга
await nextTick();

// Теперь можно проверить вновь созданный DOM
inspectTheDOM();
```

Если вы используете Options API, то код будет выглядеть так:

```javascript
await this.$nextTick();
```

"Тик" - это один цикл обновления. Сначала Vue слушает все изменения реактивности, затем производит обновления DOM в одной пакетной операции. Затем начинается следующий "тик".

Если вы внесли изменения в приложение, которые должны изменить отображение, необходимо дождаться следующего "тика", чтобы эти изменения отобразились.

### Упрощенный способ передачи множества пропов

Вместо передачи множества пропов в компонент по отдельности:

```html
<template>
  <User
    :name="user.name"
    :profile="user.profile"
    :twitter="user.twitter"
    :location="user.location"
    :framework="user.framework === 'Vue' ? 'Number one' : 'Number two'"
  />
</template>
```

Можно взять целый объект и автоматически привязать все его свойства к компоненту в качестве пропов:

```html
<template>
  <User v-bind="user" />
</template>

<script setup>
import User from './User.vue';

const user = {
  name: 'Anakin',
  profile: 'ani-profile.jpg',
  twitter: '@TatooineJedi',
  location: 'Undisclosed',
  framework: 'Vue',
};
</script>
```

### Vue to Web Component in 3 Easy Steps

Вот как можно создать веб-компоненты в Vue.

1. Создайте пользовательский элемент из компонента Vue с помощью `defineCustomElement`:

```javascript
import { defineCustomElement } from 'vue';
import MyVueComponent from './MyVueComponent.vue';

const customElement = defineCustomElement(MyVueComponent);
```

2. Зарегистрируйте пользовательский элемент в DOM:

```javascript
customElements.define('my-vue-component', customElement);
```

3. Используйте пользовательский элемент в HTML:

```html
<html>
<head></head>
<body>
<my-vue-component></my-vue-component>
</body>
</html>
```

Теперь у вас есть пользовательский веб-компонент, который не требует фреймворка и может работать нативно в браузере! Дополнительные подробности можно найти в документации.


### 18. Вложенные слоты

При создании все большего количества абстракций с помощью Vue вам может потребоваться начать вкладывать ваши слоты:
```html
<!-- Parent.vue -->
<template>
  <Child>
    <!-- Мы берем содержимое из слота предка
         и рендерим его внутри слота ребенка -->
    <slot />
  </Child>
</template>
```

Это работает аналогично тому, как вы бы поймали ошибку и затем снова выбросили ее с помощью блока try...catch:
```javascript
try {
  // Поймать ошибку
  reallyRiskyOperation();
} catch (e) {
  // Затем снова выбросить что-то другое для следующего
  // уровня, чтобы его поймать и обработать
  throw new ThisDidntWorkError('Ой, прости');
}
```

### 19. Рекурсивные слоты

Я решил проверить, смогу ли создать компонент v-for, используя только шаблон. По пути к этому я также узнал, как использовать слоты рекурсивно.

Так выглядит этот компонент:
```html
<!-- VFor.vue -->
<template>
  <div>
    <!-- Рендерим первый элемент -->
    {{ list[0] }}
    <!-- Если у нас есть еще элементы, продолжаем!
         Но удаляем элемент, который мы только что отобразили -->
    <v-for
      v-if="list.length > 1"
      :list="list.slice(1)"
    />
  </div>
</template>
```

Если вы хотите сделать это с помощью scoped слотов - и почему бы вам так не сделать?! - это займет всего несколько дополнительных шагов:
```html
<template>
  <div>
    <!-- Передаем элемент в слот для отображения -->
    <slot v-bind:item="list[0]">
      <!-- По умолчанию -->
      {{ list[0] }}
    </slot>
    <v-for
      v-if="list.length > 1"
      :list="list.slice(1)"
    >
      <!-- Рекурсивно передавать scoped слот вниз -->
      <template v-slot="{ item }">
        <slot v-bind:item="item" />
      </template>
    </v-for>
  </div>
</template>
```

Вот как используется этот компонент:
```html
<template>
  <div>
    <!-- Обычный список -->
    <v-for :list="list" />
    <!-- Список с выделенными элементами -->
    <v-for :list="list">
      <template v-slot="{ item }">
        <strong>{{ item }}</strong>
      </template>
    </v-for>
  </div>
</template>
```

Для более подробного объяснения этого примера и вложенных слотов ознакомьтесь с моей статьей в блоге. 

### 20. Условное отображение слотов

Сначала я покажу вам, как это сделать, а потом мы поговорим о том, почему вам может понадобиться скрыть слоты.

У каждого компонента Vue есть специальный объект $slots, в котором хранятся все ваши слоты. Слот по умолчанию имеет ключ defaultsи, а именованные слоты используют свое имя в качестве ключа:
```javascript
const $slots = {
  defaults: <default slot>,
  icon: <icon slot>,
  button: <button slot>,
};
```

Однако этот объект $slots содержит только слоты, применяемые к компоненту, а не все определенные слоты.

Вот этот компонент, который определяет несколько слотов, включая пару именованных:
```html
<!-- Slots.vue -->
<template>
  <div>
    <h2>Здесь есть несколько слотов</h2>
    <slot />
    <slot name="second" />
    <slot name="third" />
  </div>
</template>
```

Если мы применим только один слот к компоненту, в нашем объекте $slots будет только этот слот:
```html
<template>
  <Slots>
    <template #second>
      Это будет применено ко второму слоту.
    </template>
  </Slots>
</template>
```
$slots = { second: <vnode> }

Мы можем использовать это в наших компонентах, чтобы определить, какие слоты применены к компоненту, например, скрывать обертку для слота:
```html
<template>
  <div>
    <h2>Обернутый слот</h2>
    <div v-if="$slots.default" class="styles">
      <slot />
    </div>
  </div>
</template>
```

Теперь обертывающий `div` будет рендериться только в том случае, если мы действительно заполним этот слот чем-то. Если мы не используем v-if, у нас будет пустой и ненужный div, если у нас нет слота. В зависимости от стиля этого div, это может испортить наш макет и выглядеть странно.

Итак, зачем нам может понадобиться условно отображать слоты?

Есть три основных причины использовать условный слот:

1. При использовании оберточных `div`, чтобы добавить стили по умолчанию.
2. Слот пустой.
3. Если мы объединяем содержимое по умолчанию со вложенными слотами.

Например, когда мы добавляем стили по умолчанию, мы добавляем `div` вокруг слота:
```html
<template>
  <div>
    <h2>Это довольно великолепный компонент, не так ли?</h2>
    <div class="default-styling">
      <slot >
    </div>
    <button @click="$emit('click')">Нажми на меня!</button>
  </div>
</template>
```

Однако, если ни одно содержимое не применено к слоту предка, у нас будет пустой div, рендеринг на странице:

```html
<div>
  <h2>Это довольно великолепный компонент, не так ли?</h2>
  <div class="default-styling">
    <!-- Нет содержимого в слоте, но этот div все равно рендерится. Ой. -->
  </div>
  <button @click="$emit('click')">Нажми на меня!</button>
</div>
```

Добавление `v-if` на оберточный `div` решает проблему. Нет содержимого, примененного к слоту? Нет проблем:

```html
<div>
  <h2>Это довольно великолепный компонент, не так ли?</h2>
  <button @click="$emit('click')">Нажми на меня!</button>
</div>
```

Вот здесь есть рабочий пример на Codesandbox, если вы хотите взглянуть.
Я написал больше советов по использованию слотов в этой статье: Tips to Supercharge Your Slots (Named, Scoped, and Dynamic).

### 21. Использование слотов по умолчанию и именованных слотов

Предположим, мы создаем компонент If и хотим использовать его двумя основными способами - с помощью слота по умолчанию или двух именованных слотов.

Только слот по умолчанию:

```html
<If :val="putConditionHere">
  Отображается только если условие истинно
</If>
```

Использование именованных слотов для доступа к обоим веткам:

```html
<If :val="putConditionHere">
  <template #true>
    Отображается только если условие истинно
  </template>
  <template #false>
    Отображается только если условие ложно
  </template>
</If>
```

Вот как нам нужно организовать слоты для этого:

```html
<template>
  <slot v-if="val" />
  <template v-if="!$slots.default">
    <slot v-if="val" name="true" />
    <slot v-if="!val" name="false" />
  </template>
</template>
```

Обратите внимание, что мы используем шаблон для группировки именованных слотов. Мы также проверяем $slots, чтобы узнать, поместили ли мы что-то в слот по умолчанию или нет.

Нам нужно сделать это, иначе мы будем отображать слот по умолчанию и true слот каждый раз, когда условие истинно, что не то, что мы хотим! Мы хотим, чтобы они были взаимоисключающими - вы можете использовать либо слот по умолчанию, либо именованный true слот.

Теперь мы можем использовать его любым способом.

Только слот по умолчанию для доступа к ветке true или с использованием двух именованных слотов для доступа к двум веткам true и false.

### 22. Стандартное содержимое с вложенными слотами

Если у вас есть несколько уровней вложенных слотов, можно использовать стандартное содержимое на каждом уровне:

```html
<!-- Parent.vue -->
<template>
  <Child>
    <slot>
      Мы в Parent!
    </slot>
  </Child>
</template>
<!-- Child.vue -->
<template>
  <div>
    <slot>
      Мы в Child!
    </slot>
  </div>
</template>
```

Содержимое слота, предоставленное наиболее высоким уровнем иерархии, переопределит все содержимое ниже. Если мы рендерим Parent, он всегда будет отображать We're in the Parent. Но если мы рендерим только компонент Child, мы получаем We're in the Child!. И если компонент, рендерящий компонент Parent, предоставляет содержимое слота, это будет иметь преимущество над всеми:

```html
<!-- Grandparent.vue -->
<template>
  <Parent>
    Хаха, этот контент управляет ими всеми!
  </Parent>
</template>
```

### 23. Стандартное содержимое с помощью слотов

Вы можете предоставить стандартный контент для слота, если ничего не предоставлено:

```html
<!-- Child.vue -->
<template>
  <div>
    <slot>
      Эй! Вы забыли что-то положить в слот!
    </slot>
  </div>
</template>
```

Это содержимое может быть любым, даже всем комплексным компонентом, который предоставляет поведение по умолчанию:

```html
<!-- Child.vue -->
<template>
  <div>
    <slot name="search">
      <!-- Можно заменить более сложным функционалом -->
      <BasicSearchFunctionality />
    </slot>
  </div>
</template>
```

### 24. Ограничения props

Props полезны, но они имеют две явные проблемы:

1. Невозможно передать разметку.
2. Они не очень гибкие.

*технически невозможно, но не то, что вы хотите делать.

Решение для этих двух проблем одно и то же, но мы доберемся до него через минуту.

Многие компоненты, которые вы создаете, являются компонентами без контента. Они предоставляют контейнер, а вы должны предоставить содержимое. Думайте о кнопке, меню, компоненте аккордеона или карточке:

```html
<Card title="Shrimp Tempura">
  <img src="picOfShrimp.jpg" />
  <div>
    <p>Вот несколько слов о темпуре.</p>
    <p>Как можно ошибиться с пищей, жаренной во фритюре?</p>
  </div>
  <a href="www.michaelnthiessen.com/shrimp-tempura">
    Узнать больше о Tempura
  </a>
</Card>
```

Вы часто можете передавать это содержимое как обычную строку. Но часто вы хотите передать целый кусок HTML, возможно, даже несколько компонентов.

Этого нельзя сделать с помощью props*.
*опять же, да, вы можете это сделать, но вам будет определенно плохо.

Props также требуют, чтобы вы планировали все будущие случаи использования компонента. Если ваш компонент Button только разрешает два значения для `type`, вы не можете просто использовать третий без изменения Button:

```html
<!-- Вы просто должны *верить*, что это сработает -->
<Button type="AWESOME" />
```

На самом деле, это компонент не разрешает...
<!-- Button.vue -->
```html
<script setup>
defineProps<{
  type: 'Primary' | 'Secondary' // AWESOME здесь не работает
}>();
</script>
```

Я не ясновидец, и полагаю, вы тоже.

Решение для этих проблем?

Я думаю, я уже намекнул на него с моим примером с карточкой выше...
...со слотами!

Слоты позволяют вам передавать любую разметку и компоненты, а также они относительно гибкие. Поэтому во многих случаях слоты просто лучше, чем props.

### 25. Сокращенный синтаксис для именованных слотов

Именованные слоты также имеют сокращенный синтаксис, который выглядит более аккуратно.

Вместо этого:
```html
<DataTable>
  <template v-slot:header>
    <TableHeader />
  </template>
</DataTable>
```

Мы можем написать это:
```html
<DataTable>
  <template #header>
    <TableHeader />
  </template>
</DataTable>
```

Нет большой разницы, но выглядит намного аккуратнее, на мой взгляд. Я думаю, символ # проще визуально различим, чем v-slot при чтении кода.

### 26. Анимации для содержимого слота

Возможно использовать анимации с содержимым слота, но есть один ключевой момент, чтобы они работали плавно:

```html
<!-- SlotWithTransition.vue -->
<template>
  <!-- Создание базового слота с анимацией -->
  <transition name="fade" mode="out-in">
    <slot></slot>
  </transition>
</template>
```

Всегда убедитесь, что контент, предоставленный слотом, имеет ключи.

Это помогает Vue отслеживать, когда срабатывать переходу:
```html
<template>
  <SlotWithTransition>
    <div v-if="isThisTrue" key="true">
      Это истина.
    </div>
    <div v-else key="false">
      Это ложь.
    </div>
  </SlotWithTransition>
</template>
```

### 27. Многоразовые компоненты - это не то, что вы думаете

Многоразовые компоненты не обязательно должны быть большими или сложными вещами.
Я часто делаю небольшие и короткие многоразовые компоненты.

Потому что мне не нужно переписывать этот код везде, его обновление становится намного проще, и я могу убедиться, что каждое OverflowMenu выглядит и работает одинаково - потому что они одинаковы!

```html
<!-- OverflowMenu.vue -->
<template>
  <Menu>
    <!-- Добавляем пользовательскую кнопку для вызова меню -->
    <template #button v-slot="bind">
      <!-- Используем bind чтобы передать обработчики клика,
      атрибуты accessibility и т.д. -->
      <Button v-bind="bind">
        <!-- используем свою иконку "..." и без текста
        для этой кнопки -->
        <template #icon>
          <svg src="./ellipsis.svg" />
        </template>
      </Button>
    </template>
  </Menu>
</template>
```

Вот мы берем компонент Menu, но добавляем к кнопке, которая его открывает, иконку "..." (троеточие).

Почти кажется, что не стоит делать из этого многоразовый компонент, потому что это всего несколько строк. Не можем ли мы просто добавить иконку каждый раз, когда мы хотим использовать Menu таким образом?

Но используется многократно десятки раз, и сейчас, если мы захотим обновить иконку или ее поведение, мы можем это сделать очень быстро. И его использование стало гораздо проще!

```html
<template>
  <OverflowMenu
    :menu-items="items"
    @click="handleMenuClick"
  />
</template>
```

### 28. Разделение слотов

Возьмем слот и разделим его на два слота:
```html
<!-- Parent.vue -->
<template>
  <Child>
    <!-- Разделение слота на несколько требует
    условия. Это позволяет вам делиться
    столько слотами, сколько вам нужно -->
    <slot v-if="left" name="left" />
    <slot v-else name="right" />
  </Child>
</template>
```

Наш компонент Child принимает только один слот, но компонент Parent принимает два.

Здесь компонент Parent переключается между использованием какого слота, в зависимости от значения left.

Мы также можем использовать стандартное содержимое слота, если один или оба слота Parent не имеют содержимого:

```html
<!-- Parent.vue -->
<template>
  <Child>
    <slot v-if="left" name="left">
      <!-- Содержимое по умолчанию работает, как и ожидалось -->
      <div key="left">По умолчанию слева</div>
    </slot>
    <slot v-else name="right">
      <div key="right">По умолчанию справа</div>
    </slot>
  </Child>
</template>
```

### 29. Улучшение возможности повторного использования путем преобразования атрибутов шаблона в слоты

Один из видов атрибутов, атрибут шаблона, можно напрямую преобразовать в слоты без особых усилий.

Это делает ваш компонент более переиспользуемым.

Атрибут text здесь является атрибутом шаблона, поскольку его используют только в шаблоне:
```html
<template>
  <button @click="$emit('click')">
    {{ text }}
  </button>
</template>
<script setup>
const props = defineProps({
  text: {
    type: String,
    required: true,
  },
});
defineEmits(['click']);
</script>
```

Он не используется в вычислениях или передается в качестве атрибута. Вместо этого он напрямую интерполируется и отображается на странице.

```html
<template>
  <button @click="$emit('click')">
    <slot />
  </button>
</template>
<script setup>
  defineEmits(['click']);
</script>
```

Это несколько упорядочивает код, но более важно, что это позволяет нам быть более гибкими в использовании компонента.

С помощью атрибута мы должны использовать компонент следующим образом:
```html
<Button text="Click me" @click="handleClick" />
```

Но с использованием слота, мы можем добавить все, что хотим:
```html
<Button @click="handleClick">
  Нажми на <strong>эту</strong> кнопку
</Button>
```

### 30. Понимание области видимости слотов

Вот лучший способ думать о scoped слотах:
Scoped слоты похожи на функции, которые передаются дочернему компоненту, который возвращает HTML.

После того, как шаблон скомпилирован, они становятся функциями, возвращающими HTML (технически vnodes), которые родительский компонент передает дочернему.

Вот простой список, который использует scoped слот для настройки способа рендеринга каждого элемента:
```html
<!-- Parent.vue -->
<template>
  <ScopedSlotList :items="items">
    <template v-slot="{ item }">
      <!-- Сделаем его жирным, просто ради удовольствия -->
      <strong>{{ item }}</strong>
    </template>
  </ScopedSlotList>
</template>
<!-- ScopedSlotList.vue -->
<template>
  <ul>
    <li
      v-for="item in items"
      :key="item"
    >
      <slot :item="item" />
    </li>
  </ul>
</template>
```

Мы можем переписать этот пример, используя функцию вместо scoped слота:
```html
<!-- Parent.vue -->
<template>
  <ScopedSlotList
    :items="items"
    :scoped-slot="(item) => `<strong>${item}</strong>`"
  >
</template>
<!-- ScopedSlotList.vue -->
<template>
  <ul>
    <li
      v-for="item in items"
      :key="item"
      v-html="scopedSlot(item)"
    />
  </ul>
</template>
```

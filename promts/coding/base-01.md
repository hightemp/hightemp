Пиши код с упором на низкую NPath complexity.
- Разбивай сложные методы на несколько маленьких, каждый с одной понятной обязанностью.
- Избегай глубокой вложенности условий; по возможности используй ранний выход (guard clauses) вместо вложенных if/else.
- Не допускай слишком большого числа разных ветвей выполнения в одном методе.
- Если логика становится ветвящейся, выноси части в отдельные приватные методы или отдельные классы/сервисы.
- Отдавай предпочтение простым конструкциям и «плоским» условиям.

Сгенерируй метод для [описание задачи], но сразу учитывай NPath complexity:
- Стремись к небольшой NPath complexity (условно не выше 50 для одного метода).
- Не делай один гигантский метод с кучей условий, лучше несколько небольших.
- Используй ранний выход для обработки невалидных данных и граничных случаев.
- По возможности избегай вложенности более 2 уровней.
- Если для упрощения кода нужно изменить интерфейс или разнести логику по нескольким классам — сделай это.


У этой задачи потенциально много ветвлений. Спроектируй решение так, чтобы NPath complexity была как можно ниже:
- Вместо длинной цепочки if/else по статусам/типам используй таблицу соответствия (map) или паттерн стратегия/полиморфизм.
- Логику ветвления распредели по нескольким небольшим методам или классам.
- Не складывай все специальные случаи в один метод-контроллер.
- Если видишь, что без усложнения структуры кода NPath complexity будет высокой — сразу предлагай более архитектурное решение (выделение сервисов, стратегий и т.п.).